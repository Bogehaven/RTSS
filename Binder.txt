[Design] Informatics and Mathematical Modelling HHL 97–12–20 Technical University of Denmark Building 321 DK–2800 Lyngby Denmark Hans Henrik Løvengreen: Design of Reactive Programs Version 1.2 Summary In this note, an approach to design of reactive programs is presented. The method is based on the events that occur between the program (system) and its environment. The events are temporally ordered in order to identify the main processes of the system. Finally, a design consisting of an abstract program is produced. This design may then be analyzed before a ﬁnal implementation is made. Contents 1 Introduction 1 2 System identiﬁcation 1 2.1 Documentation ..................................... 3 3 System structuring 4 3.1 Event sequences ..................................... 4 3.2 Finding event sequences ................................ 7 4 Program Structuring 8 4.1 An abstract programming language .......................... 8 4.2 Transformation into abstract programs ........................ 10 4.3 Adding data ﬂow .................................... 11 c 1997–2001 Hans Henrik Løvengreen 1 Introduction A reactive program responds to external stimuli over time. Such programs typically appear in embedded systems monitoring and controlling a number of external physical devices. Reactive systems are often implemented as concurrent programs. The design method presented in this note aims at reaching an abstract design consisting of a number of components interacting with each other. The components may be active ones representing processes or passive ones representing shared data stores (monitors). Given an informal requirements speciﬁcation, the method deﬁnes three steps in order to reach a design: 1. System identiﬁcation The program system is identiﬁed by ﬁnding the events linking the system and its environment. These events by deﬁnition consitute the interface between the system and its environment. The events may be divided into input and output events. Also events are typed to indicate the information they carry. 2. System structuring In this step, the behaviour of the system is characterized. This is done by identifying temporal orders among the system events. The orderings are described in a terse textual notation. This results in a number of event sequences each corresponding to a sequential ﬂow of events. The behaviour expressions are by default put in parallel at the outermost system level, and thus they identify the processes of the system. 3. Program structuring In this step, the event sequences are reﬁned into (CSP-like) abstract programs. During this process, the information ﬂow in the system is determined, and possible monitor components are identiﬁed. Having reached a design, it is now possible to analyze the system. This may include its functionality (does it work correctly?) or its implementability. Such analysis is outside the scope of this note. Implementation of the abstract model is not yet part of this note. Given a basic knowledge concurrent programming techniques, it should cause no problems to reach an implementation in a current programming language, eg. Java or Ada. Often embedded systems involve real-time requirements to be satisﬁed. In this note, it is assumed that the program takes no signiﬁcant time to react. A further analysis of schedulability is out of the scope of this note. The method presented in this note is largely based upon ideas developed by A.P. Ravn, Hans Rischel and Benny Mortensen [RMR87]. 2 System identiﬁcation By a system, we generally understand a structured collection of entities of a given universe to be considered as a whole. The system boundary divides the universe into thoses entities which are part of the system, and those belonging to the rest of the universe, the environment of the system. The system entities are often called components. 1 In the ﬁrst step of the method, the system boundary is found by identifying the (interface) events that take place between the system and its environment. An event is the abstraction of an interaction, ie. an activity involving more than one component. By modelling the interaction as an event, we consider the activity to be atomic: Either the activity results in an overall e ect, or there is no e ect at all. For instance, the input of data from a user may involve setting up dialog boxes etc., but only when the user clicks the OK-button, the activity is considered an event. Events are abstract entities and need not correspond to physical events like raising the voltage on a line or pressing a button. Any timing period should be considered an interface event by it own. This way, the system will become event driven: the system will not act spontaneously, only as reaction to events. The proper choice of events that suit the purpose of designing the system is often diÿcult. A guideline is to make events correspond to the activities that the system user would like to consider atomic. A technique to ﬁnd candidates for events is to mark the active verbs of the informal system requirements speciﬁcation. These may then be analyzed to see whether they correspond to external activities, interface events, or internal activities. The events may be partitioned into input events and output events. An input event carry information from the environment to the system and/or is (as least partly) under the control of the environment. An output event carry information from the system to the environment and is often under the total control of the system. The distinction between input and output may, however, not always be clear. Data Types Events are typed. Each event has an associated data type which represents the information exchanged during the event. Often events are simple signal not carrying other information than the fact that they take place. Any well-deﬁned type system could be used for typing events, such as the ML-type system, or types of speciﬁcation languages such as VDM or Z. Here we propose a traditional type system comprising simple types: NUMBER  Some number.  TOKEN  Some unique code.  {id1, . . . , idn }  Enumeration of distinct symbolic values.  VOID  Unit type with only one value: () .  and composite types:  T1 × . . . × Tn  Cartesian product (record, structure).  T1| . . . |Tn  Union.  T − LIST  List of T-elements.  T − SET  Set of T-elements.  where the Ts are types. In this note, we shall not dwell upon issues such as type equivalence, subtyping etc. 2 2.1 Documentation The interface events identiﬁed may be documented in an event list which for each event deﬁnes its direction (input or output), its data type (perhaps not yet deﬁned), and its legend. Futhermore, the relation of events to the environment may be shown in a system diagram showing the units in the environment and the events that link them to the system. Example (Taximeter) Consider the following informal speciﬁcation of a simple taximeter: The taximeter can be switched on and o . When being switched on, the amount due shown on a display must be reset. While the taximeter is switched on, the amount should be incremented each minute as well as for each 100 meter signal received from the wheels. When switched o , the ﬁnal amount remains on the display. When a ”KM”-button is pressed, the total distance covered with the taximeter switched on must be shown for 10 seconds on a separate display. We start by underlining the active verbs in order to ﬁnd candidates for events: The taximeter can be switched on and o . When being switched on, the amount due shown on a display must be reset. While the taximeter is switched on, the amount should be incremented each minute as well as for each 100 meter signal received from the wheels. When switched o , the ﬁnal amount remains on the display. When a ”KM”-button is pressed, the total distance covered with the taximeter switched on must be shown for 10 seconds on a separate display. We ﬁnd that most of the marked verbs correspond directly to interface events. However, the reset and incrementation of the amount are internal acitivities whose result can be presented to the user by a common show event. Furthermore, since we assume that the display will not change if not asked to, the requirement that the amount remains, can be accomplished by lack of show events. The events are naturally divided into input and output events as follows: EVENT LIST: Input event Data type Legend On VOID Taximeter is switched on. O VOID Taximeter is switched o . 100m VOID Signal for each 100 meter. KM VOID KM-button pressed. Min VOID Regular signal from minute-clock. 10s VOID Signal 10 sec. after Start10sec. 3 Output event Data type Legend Show  NUMBER  Show number on amount display.  ShowKm  NUMBER  Show number on distance display.  ClearKm  VOID  Clears distance display.  Start10s  VOID  Request for 10 sec. signal.  We assume that there is a minute-clock that ticks with regularly with a one minute period. If it is desired to synchronize this clock, a StartMin signal could be introduced. For the 10-second clock, we presume that it will signal once 10 seconds after Start10s. Finally, we present a system diagram for the taximeter: 3 System structuring In order to determine the system structure, the events are partially ordered according to the sequence in which they should occur in any system behaviour. For this, we use event sequences which characterize independent sequential behaviours of the system. Each independent event sequence gives rise to a major process of the program. 3.1 Event sequences The syntax of event sequence expressions is given by: &#3; s ::= e | int | [ s ] | s | s1; s2 | s1 [] s2 | s1 k s2 Here e represents an event, and each s represents an event sequence. An event sequence expression describes a behaviour according to the following informal semantics: e Event. Represents the occurrence of an event e. int Internal. Represents the occurrrence of an anonymous internal event. 4 [ s ] Option. May behave like s or may internally choose to skip s. &#3;s Repetition. Behaves as s any number of times. May terminate at the start of each iteration. s1; s2 Sequential composition. Behaves ﬁrst like s1 and then like s2. s1 [] s2 Choice. Behaves like s1 or s2 depending on the ﬁrst events of these. s1 k s2 Parallel composition. Behaves like s1 and s2 in parallel. That is, the behaviour of s1 takes place concurrently with that of s2 except for common events of s1 and s2 which must be synchronized. Terminates when both s1 and s2 have terminated. Event sequences may be given names using deﬁnitions of the form: name = s Recursively deﬁned event sequences are permitted and may be used in cases where the structure imposed by repetition may be too restrictive. Syntax The above grammer deﬁnes the abstract structure of event sequence expressions. When writing down such expressions, parentheses are used to resolve the ambiguity. However, in order to avoid lots of parentheses, we adopt the convention that the operators binds in the following order: &#3; ; [] k where &#3; binds strongest. Eg. the expression: A; B&#3; ; C [] C ; D k E is understood as ((A;(B)&#3; ; C ) [] (C ; D)) k E Semantics As semantic model for event sequences, we use a kind of automata or transition system. An event transition graph is directed graph whose edges may be labelled with events. Unlabelled edges correspond to internal events. Each node of the graph correspond to a state of the system. One of the nodes is marked as the initial state. The transition graph represents an abstract device (or machine) which may execute by performing events in cooperation with its environment or by performing internal events by itself. In any state represented by a certain node, the system is willing to engage in any event labelling an outgoing edge. Such events are said to be enabled. We may think of the machine as having a button for each event. When an event is enabled, the corresponding button lights up. Now the environment may select and press a lit button. Hereby the machine will move along the edge labelled by that event. If there are several edges labelled with the event, one of them will be chosen by the machine. Now the machine has entered a new state, and a new set of events will be enabled. If a state has one or more unlabelled outgoing edges, the machine has the right to, but no obligation to, chose one of these by itself. As an example of an event transition graph consider the following: 5 H The initial state is marked by an arrow. This graph describes a machine that will initially perform the event A. After that, it may engage in B, or it may internally decide to abondon B in which case it will perform F. If, on the other hand, B is taken, it will be willing to engage in any number of C followed by D sequences. However, inbetween these, also the event E is enabled, and if the environment choses this, only the event G followed by H are possible, after which the machine is back in its initial state. We would like this event transition graph to be the meaning of the event sequence (A;(B;(C ; D)&#3; ; E [] int; F); G; H )&#3; In general, we would like to deﬁne the semantics of an event sequence by generating a transition graph. To do this, we need to combine such graphs. For this purpose, it should be possible to mark nodes in transition graphs as terminated, indicating a state where the current behaviour may end. Here we indicate terminated nodes by small open circles. Furhtermore, let −s → denote the graph generated for s where − represent all the edges leaving the initial state, and → represent all the edges leading to the ﬁnal node. Now, the graph corresponding to an event sequence can be deﬁned as follows: e e int s1 ; s2 s1 s2 The graph of [ s ] is given by the deﬁnition: &#1; [ s ] =(s [] int) 6 The graph of s1 k s2 is given by interleaving of the graphs of s1 and s2. Normally, however, we are only interested in the graphs of (almost) sequential event sequences. From the graph semantics we see that a repetition of, say, an event A can be terminated externally by another event B expressed by A&#3; ; B or terminated internally (eg. modelling a counter reaching some value) expressed by A&#3; ; int. 3.2 Finding event sequences When ordering the events of a system, we aim at having a number of sequential processes running in parallel at the outermost level since this will give the most e ective implementation in most langauges. Thus, we initially try to identify a number of (largely) independent sequential event orderings. It is important to stress that the event sequences should describe the meaningful dialogues between the system and the environment. This means that events should appear only in situations where they make sense even though they may occur physically at other times. A technique to ﬁnd such a set of independent behaviour expressions is to proceed as follows: 1. First, only the input events are considered. The inputs events may be compared pairwise and it may be determined whether they are should appear sequentially (;), as alternatives ([]), together in some order (), or whether they are (largely) independent. In the latter case, they are put in separate event sequences. 2. Repetition and perhaps internal events are added to the event sequences. 3. Finally the output events can be inserted after the input events they are caused by. This results in a number of independent event sequences which may at last be combined in parallel to make up the total system. To be honest, the independent event sequence expression may sometime be only “almost sequential”. The reason being that when adding the output events, we often ﬁnd that two of these may occur in either order. Rather than making an arbitrary choice, we may put them in parallel and leave it to the implementation phase to ﬁnd a proper order. Sometimes, two (or more) event sequences should synchronize by participating in a common internal activity. In order to reﬂect this, new named internal events may be introduced and used in several event sequences. Example (Taximeter continued) Looking at the input events we ﬁnd that O should follow On. Furthermore, the Min event and 100m only make sense, when the taximeter is switched on, ie. inbetween On and O . Furthermore, Min and 100m may occur at the same places with the same e ect, and thus they are naturally seen as alternatives. The KM event may occur at any time, but the 10s signal only makes sense when showing the distance. Adding repetition, this leaves us with two independent event expressions: 7 (On;(Min [] 100m)&#3; ; O )&#3; (KM ; 10s)&#3; Adding the output events and naming the independent sequences, we get: count =(On; Show; ((Min [] 100m); Show)&#3; ; O )&#3; inform =(KM ;(Start10s k ShowKm); 10s; Clear)&#3; Finally, the two expressions are combined in parallel: taximeter = count k inform Thus, the taximeter should comprise two concurrent processes. 4 Program Structuring The purpose of this design step is ﬁrst of all to identify the dataﬂow in the system and to introduce the data stores needed. These may either be local to a proces taking the form of usual variables, or they may be shared between processes. The result of this analysis is documented by an abstract program written in a general process language. Here we choose a CSP-like language where processes communicate over synchronous channels corresponding to the system events. The processes do not share variables. Shared data components are represented by server-like processes called state monitors. The rationale of using CSP is that this model clearly separates local computation from interchange of information. The model may readily be implemented in both monitor-based as well as communication-based programming languages. 4.1 An abstract programming language Our CSP-like proces langauge has the following syntax: p ::= a | skip | g → p | do p od | exit | p1; p2 | p1 [] p2 | p1 k p2 | var x : T | chan c : T a ::= x := e | c ! e | c ? x g ::= b | c ! e | c ? x | g1, g2 Here p is a proces, a an action, g a guard, c a channel, x a variable, e an expression, b a boolean expression and T a type. 8 Processes Processes performs (atomic) actions. The behaviour of a process expression is informally given by: a Action. Process which performs the action a and then terminates. skip Skip. Process that cannot perform any action and just terminates. g → p Guarded process. Process which which ﬁrst passes the guard g and then behaves like the process p. The guard may declare variables whose scope is p. do p od Loop. Process which repeatedly performs p. May be terminated by execution af an exit in p. exit Exit. Exits the innermost enclosing loop. p1; p2 Sequential composition. Process which ﬁrst behaves like p1. When p1 terminates, it behaves like p2. p1 [] p2 Choice. Process which may behave like p1 or p2, depending on the ﬁrst actions of these. If these are communications, the choice is determined by the current communication capabilities. p1 k p2 Parallel composition. Process which behaves like p1 in parallel with p2. Terminates, when both p1 and p2 terminate. Matching communications between p1 and p2 are synchronized. var v : T Variable declaration. Declares a variable x of type T. The scope of x is deﬁned to be the rest of the (sequentially composed) process list in which the declaration occurs. chan c : T Channel declaration. Declares a channel c over which values of type T may be communicated. The scope of c is deﬁned to be the rest of the (sequentially composed) process list in which the declaration occurs. A process which is constructed without parallel composition is called a sequential process. Actions An action is an atomic activity. An action may either be internal or it may generate a communication event. x := e Assignment. Evaluates the value of e and assigns it to x. c ! e Output. Evaluates e and outputs it on channel c. c ? x Input. Inputs a value from channel c and assigns it to the variable x. The variable x is implicitly declared by the construct. The communication is synchronous (as in CSP [Hoa78]), that is, an output action c ! e will wait until a matching input action c ? x can take place in a concurrent process. 9 Guards A guard is an condition which must be passed before the process can proceed. A guard may be a boolean guard, an input/output guard, or a combination of these. All parts of a guard must be passed atomically for the guard to be passed. A boolean guard is passable only if it evaluates to true. An input/output guard is passed by performing the communication. Note: The syntax and semantics allow for several input/outputs to be passed atomically, but this may be hard to implement. Types and expressions For types we may use the same types as for events, but maybe extended with more concrete types such as Int or Real. We asssume the existence of a standard (mathematical) notation for expressions, that expressions are well-typed, and that no expression evaluation will fail. Deﬁnitions As for event sequence expressions, we may deﬁne names for processes and use these. Futhermore processes may be recursively deﬁned. Conventions We introduce a few convention in order to facilitate writing and reading of abstract programs: • As for event sequence expressions, we introduce the convention that the operators bind in the following order (strongest ﬁrst): ; → [] k When this is not appropiate, we use parentheses or square brackets to indicate the intended structure. Since ;, [], k are associative, we may consider these to apply to lists of processes. • If the type of a channel is VOID, input and output are just written as c ? and c !. • Variables may be initialized: var x : T := e corresponding to var x : T; x := e. 4.2 Transformation into abstract programs As can be seen, the syntax of abstract programs resemble that of event sequences. In fact, each independent event sequence can be transformed into an abstract program skeleton by the following modﬁcations: • Events are replaced by communications. For each event e, a channel with the same name and type as the event is implicitly declared. Now, each input event I is is reﬁned into an input action: I ? x and each output event O is reﬁned into an output action: O ! e 10 • Seqential composition of events carry over to processes. • Likewise for choices. However, the presence of a choice (typically between input events) is usually emphasized by using the communications as guards. For instance, I1; ... [] I2; ... is transformed into: [I1 ? x1 → ... [] I2 ? x2 → ...] &#3;• Repetion s is generally replaced by a loop: do ps od where ps is the transformation of s. &#3;However, whereas termination of s may occur implicly at the start of each iteration, termination of the do loop must be programmed explicitly. If a repetition is terminated by an event (typically an input event) this event must be considered as a possibility at the start of each iteration. If, for instance, the event sequence is (I1; ...)&#3; ; I2, a choice between I1 and I2 must be made at the start of each iteration. If I2 occurs, the loop is left: do I1 ? x → ... [] I2 ? x → exit od If the repetition is terminated by an internal event, this must be transformed into a concrete exit condition. For instance, (I1; ...)&#3; ; int should be transformed into: do I1 ? x → ... [] b → exit od where b is some boolean termination condition. • Parallel composition of output events within an event sequence may be resolved into a speciﬁc order. • Outermost parallel composition of event sequences carry over to the corresponding processes. 4.3 Adding data ﬂow Having generated the abstract program skeleton processes, we now look for data sources for output data. In general, the data needed by an output O ! in some process may have three sources. • The data may be found as a function f of a recently received data value still present in a local variable x. In this case, the output takes the form O ! f (x). • The data may be computed from the history of the process itself. In that case, a process-wide variable is introduced, updated in connection with the relevant events, and ﬁnally used in the output action. • The data may be computed using the history of one or more other processes. If so, a state monitor to hold the relevant information produced by the other process(es) is introduced. A state monitor is a passive process which may be operated upon by communicating with it over a set of internal channels. 11 If the output data still cannot be calculated, the system simply receives too little information to generate that output! Either more input events must be added, or the events must be processed in more situations. Structure diagram In order to illustrate the structure as well as the data ﬂow in the system, a structure diagram may be drawn. The diagram should show the internal structure of the program, ie. the processes, the channels, the state monitors, and the external units. In the diagrams, we use circles to represent processes, rectangles to represent state monitors, hexagons to represent external units and arrows to represent internal and external channels. Example (Taximeter contd.) First, the abstract process skeletons are derived from the event sequences. We get two processes named after the corresponding event sequences. For the Count process, we should note that in each iteration, there are three possible next events: Min, 100m and the terminating O . This can be programmed as shown: Count = do On ?; Show ! ... ; do O ? → exit [] [Min ? → skip [] 100m ? → skip]; Show ! ... od od 12 The program illustrates the possibility of having nested choices. The transformation of Inform is straightforward: Inform = do KM ?; ShowKm ! ... ; Start10s !; 10s ?; od Now we look at the data ﬂow. We see that we need to deliver output to Show and ShowKm. For Show we ﬁnd that the amount can be calculated on basis of the events occurring in Count. Thus, we can make do with a local variable of the Count process accumulating the amount. For ShowKm we ﬁnd that it cannot be calculated on basis of the events ocurring in Inform itself. But, luckily, it can be calculated from the events processed by Count, since it precisely processes 100m signals when the taximeter is switched on. Thus the Count proces has the information needed by Inform. Rather than having them communicate directly, we introduce an intermediate state monitor Dist which can update and deliver the total distance covered with the taximeter on. Communication with the state monitor can be done through channel DistIncr which should make it increment the distance, and channel DistGet which should deliver the current distance. This structure may be depicted in a structure diagram showing the processes, monitors and channels of the system: 13 Now, the process skeleton may be completed by adding the local variables, and the communications with the state monitor: Count = var amount : Real; do On ?; amount := StartFee; Show ! amount; do O ? → exit [] [Min ? → skip [] 100m ? → DistIncr ! ]; amount := amount + DeltaAmount; Show ! amount od od Inform = do KM ?; DistGet ? km; ShowKm ! km; Start10s !; 10s ?; od The Dist monitor itself is readily implemented: Dist = var km : Real := 0. 0; do DistIncr ? → km := km + 0. 1; [] DistGet ! km → skip od References [Hoa78] C.A.R. Hoare. Communicating sequential processes. Communication of the ACM, 21(8), August 1978. [RMR87] Hans Rischel, Benny Gra Mortensen, and Anders P. Ravn. Konstruktion af form°alsbundne systemer. Teknisk Forlag, 1987. (In Danish). 14  1 FUNDAMENTALS OF REAL- TIME SYSTEMS     The term “ real time ” is used widely in many contexts, both technical and conventional. Most people would probably understand “ in real time ” to mean “ at once ” or  “ instantaneously. ” The Random House Dictionary of the English Language (2nd unabridged edition, 1987), however, deﬁnes  “ realtime ” as pertaining to applications in which the computer must respond as rapidly as required by the user or necessitated by the process being controlled . These deﬁ nitions, and others that are available, are quite different, and their differences are often the cause of misunderstanding between computer, software and systems engineers, and the users of real - time systems. On a more pedantic level, there is the issue of the appropriate writing of the term “ real - time.” Across technical and pedestrian literature, various forms of the term, such as real time, real - time, and realtime may appear. But to computer, software, and systems engineers the preferred form is real - time, and this is the convention that we will follow throughout this text. Consider a computer system in which data need to be processed at a regular rate. For example, an aircraft uses a sequence of accelerometer pulses to determine its position. Systems other than avionic ones may also require a rapid response to events that occur at nonregular rates, such as handling an overtemperature failure in a nuclear power plant. Even without deﬁ ning the term “ real - time,” it is probably understood that those events demand timely or  “ real - time ” processing. Real-Time Systems Design and Analysis: Tools for the Practitioner, Fourth Edition. Phillip A. Laplante and Seppo J. Ovaska. © 2012 the Institute of Electrical and Electronics Engineers, Inc. Published 2012 by John Wiley & Sons, Inc. FUNDAMENTALS OF REAL-TIME SYSTEMS Now consider a situation in which a passenger approaches an airline check in counter to pick up his boarding pass for a certain ﬂight from New York to Boston, which is leaving in ﬁve minutes.The reservation clerk enters appropriate information into the computer, and a few seconds later a boarding pass is printed. Is this a real - time system? Indeed, all three systems — aircraft, nuclear power plant, and airline reservations — are real - time, because they must process information within a speciﬁed interval or risk system failure.Although these examples may provide an intuitive deﬁnition of a real - time system, it is necessary to clearly comprehend when a system is real - time and when it is not. To form a solid basis for the coming chapters, we ﬁ rst deﬁne a number of central terms and correct common misunderstandings in Section 1.1 . These deﬁnitions are targeted for practitioners, and thus they have a strong practical point - of - view. Section 1.2 presents the multidisciplinary design challenges related to real - time systems. It is shown that although real - time systems design and analysis are subdisciplines of computer systems engineering, they have essential connections to various other ﬁelds, such as computer science and electrical engineering — even to applied statistics. It is rather straightforward to present different approaches, methods, techniques, or tools for readers, but much more difﬁcult to convey the authors ’  insight on real - time systems to the audience. Nevertheless, our intention is to provide some insight in parallel with speciﬁc tools for the practitioner. Such insight is built on practical experiences and adequate understanding of the key milestones in the ﬁeld. The birth of real - time systems, in general, as well as a selective evolution path related to relevant technological innovations, is discussed in Section  1.3 . Section 1.4 summarizes the preceding sections on fundamentals of real - time systems. Finally, Section 1.5 provides exercises that help the reader to gain basic understanding on real - time systems and associated concepts. 1.1   CONCEPTS AND MISCONCEPTIONS The fundamental deﬁnitions of real - time systems engineering can vary depending on the resource consulted. Our pragmatic deﬁnitions have been collected and reﬁ ned to the smallest common subset of agreement to form the vocabulary of this particular text. These deﬁnitions are presented in a form that is intended to be most useful to the practicing engineer, as opposed to the academic theorist. 1.1.1   Deﬁnitions for Real - Time Systems The hardware of a computer solves problems by repeated execution of machine - language instructions, collectively known as software. Software, on the other hand, is traditionally divided into system programs and application programs. CONCEPTS AND MISCONCEPTIONS System programs consist of software that interfaces with the underlying computer hardware, such as device drivers, interrupt handlers, task schedulers, and various programs that act as tools for the development or analysis of application programs. These software tools include compilers, which translate high - level language programs into assembly code; assemblers, which convert the assembly code into a special binary format called object or machine code; and linkers/locators, which prepare the object code for execution in a speciﬁ c hardware environment. An operating system is a specialized collection of system programs that manage the physical resources of the computer.As such, a real - time operating system is a truly important system program (Anh and Tan, 2009 ). Application programs are programs written to solve speciﬁc problems, such as optimal hall - call allocation of an elevator bank in a high - rise building, inertial navigation of an aircraft, and payroll preparation for some industrial company. Certain design considerations play a role in the design of system programs and application software intended to run in real - time environments. The notion of a “ system ” is central to software engineering, and indeed to all engineering, and warrants formalization. Deﬁ nition: System A system is a mapping of a set of inputs into a set of outputs. When the internal details of the system are not of particular interest, the mapping function between input and output spaces can be considered as a black box with one or more inputs entering and one or more outputs exiting the system (see Fig. 1.1 ). Moreover, Vernon lists ﬁve general properties that belong to any  “ system ” (Vernon, 1989 ): 1. A system is an assembly of components connected together in an organized way. 2. A system is fundamentally altered if a component joins or leaves it. 3.  It has a purpose. 4.  It has a degree of permanence. 5.  It has been deﬁned as being of particular interest. Inputs Outputs Figure 1.1. A general system with inputs and outputs. 4  Camera  FUNDAMENTALS OF REAL-TIME SYSTEMS Display  Sensors  Real-Time Control System  Actuators  ... ... Figure 1.2. A real - time control system including inputs from a camera and multiple sensors, as well as outputs to a display and multiple actuators. Figure 1.3. A classic representation of a real - time system as a sequence of schedulable jobs. Every real - world entity, whether organic or synthetic, can be modeled as a system. In computing systems, the inputs represent digital data from hardware devices or other software systems.The inputs are often associated with sensors, cameras, and other devices that provide analog inputs, which are converted to digital data, or provide direct digital inputs. The digital outputs of computer systems, on the other hand, can be converted to analog outputs to control external hardware devices, such as actuators and displays, or used directly without any conversion (Fig. 1.2 ). Modeling a real - time (control) system, as in Figure  1.2 , is somewhat different from the more traditional model of the real - time system as a sequence of jobs to be scheduled and performance to be predicted, which is comparable with that shown in Figure  1.3 .The latter view is simplistic in that it ignores the usual fact that the input sources and hardware under control may be highly complex. In addition, there are other, “ sweeping ” software engineering considerations that are hidden by the model shown in Figure  1.3 . Look again at the model of a real - time system shown in Figure  1.2 . In its realization, there is some inherent delay between presentation of the inputs (excitation) and appearance of the outputs (response).This fact can be formalized as follows: Deﬁ nition: Response Time The time between the presentation of a set of inputs to a system and the realization of the required behavior, including the availability of all associated outputs, is called the response time of the system. CONCEPTS AND MISCONCEPTIONS How fast and punctual the response time needs to be depends on the characteristics and purpose of the speciﬁ c system. The previous deﬁnitions set the stage for a practical deﬁnition of a real - time system. Deﬁnition: Real - Time System ( I ) A real - time system is a computer system that must satisfy bounded response time constraints or risk severe consequences, including failure. But what is a “ failed ” system? In the case of the space shuttle or a nuclear power plant, for example, it is painfully obvious when a failure has occurred. For other systems, such as an automatic bank teller machine, the notion of failure is less obvious. For now, failure will be deﬁned as the “ inability of the system to perform according to system speciﬁcation, ” or, more precisely: Deﬁnition: Failed System A failed system is a system that cannot satisfy one or more of the requirements stipulated in the system requirements speciﬁ cation. Because of this deﬁnition of failure, rigorous speciﬁcation of the system operating criteria, including timing constraints, is necessary.This matter is discussed later in Chapter 5 . Various other deﬁnitions exist for  “ real - time, ” depending on which source is consulted. Nonetheless, the common theme among all deﬁnitions is that the system must satisfy deadline constraints in order to be correct. For instance, an alternative deﬁnition might be: Deﬁnition: Real - Time System ( II ) A real - time system is one whose logical correctness is based on both the correctness of the outputs and their timeliness. In any case, by making unnecessary the notion of timeliness, every system becomes a real - time system. Real - time systems are often reactive or embedded systems. Reactive systems are those in which task scheduling is driven by ongoing interaction with their environment; for example, a ﬁre - control system reacts to certain buttons pressed by a pilot. Embedded systems can be deﬁned informally as follows: FUNDAMENTALS OF REAL-TIME SYSTEMS  Deﬁnition: Embedded System An embedded system is a system containing one or more computers (or processors) having a central role in the functionality of the system, but the system is not explicitly called a computer. For example, a modern automobile contains many embedded processors that control airbag deployment, antilock braking, air conditioning, fuel injection, and so forth. Today, numerous household items, such as microwave ovens, rice cookers, stereos, televisions, washing machines, even toys, contain embedded computers. It is obvious that sophisticated systems, such as aircraft, elevator banks, and paper machines, do contain several embedded computer systems. The three systems mentioned at the beginning of this chapter satisfy the criteria for a real - time system. An aircraft must process accelerometer data within a certain period that depends on the speciﬁcations of the aircraft; for example, every 10 ms. Failure to do so could result in a false position or velocity indication and cause the aircraft to go off - course at best or crash at worst. For a nuclear reactor thermal problem, failure to respond swiftly could result in a meltdown. Finally, an airline reservation system must be able to handle a surge of passenger requests within the passenger ’s perception of a reasonable time (or before the ﬂ ights leave the gate). In short, a system does not have to process data at once or instantaneously to be considered real - time; it must simply have response times that are constrained appropriately. When is a system real - time? It can be argued that all practical systems are ultimately real - time systems. Even a batch - oriented system — for example, grade processing at the end of a semester or a bimonthly payroll run — is real time. Although the system may have response times of days or even weeks (e.g., the time that elapses between submitting the grade or payroll information and issuance of the report card or paycheck), it must respond within a certain time or there could be an academic or ﬁnancial disaster. Even a word processing program should respond to commands within a reasonable amount of time or it will become torturous to use. Most of the literature refers to such systems as soft real - time systems. Deﬁnition: Soft Real - Time System A soft real - time system is one in which performance is degraded but not destroyed by failure to meet response - time constraints. Conversely, systems where failure to meet response - time constraints leads to complete or catastrophic system failure are called hard real - time systems. Deﬁnition: Hard Real - Time System A hard real - time system is one in which failure to meet even a single deadline may lead to complete or catastrophic system failure. CONCEPTS AND MISCONCEPTIONS Firm real - time systems are those systems with hard deadlines where some arbitrarily small number of missed deadlines can be tolerated. Deﬁnition: Firm Real - Time System  A ﬁrm real - time system is one in which a few missed deadlines will not lead to total failure, but missing more than a few may lead to complete or catastrophic system failure. As noted, all practical systems minimally represent soft real - time systems. Table  1.1  gives an illustrative sampling of hard, ﬁrm, and soft real - time systems. There is a great deal of latitude for interpretation of hard, ﬁrm, and soft real - time systems. For example, in the automated teller machine, missing too many deadlines will lead to signiﬁcant customer dissatisfaction and potentially even enough loss of business to threaten the existence of the bank. This extreme scenario represents the fact that every system can often be characterized any way — soft, ﬁrm, or hard — real - time by the construction of a supporting scenario. The careful deﬁnition of systems requirements (and, hence, expectations) is the key to setting and meeting realistic deadline expectations. In any case, it is a principal goal of real - time systems engineering to ﬁ nd ways to transform hard deadlines into ﬁrm ones, and ﬁrm ones into soft ones. Since this text is mostly concerned with hard real - time systems, it will use the term real - time system to mean embedded, hard real - time system, unless otherwise noted. It is typical, in studying real - time systems, to consider the nature of time, because deadlines are instants in time. Nevertheless, the question arises, “ Where do the deadlines come from? ” Generally speaking, deadlines are based on the underlying physical phenomena of the system under control. For TABLE 1.1. A Sampling of Hard, Firm, and Soft Real - Time Systems System    Real - Time Explanation Classiﬁ cation   Avionics weapons delivery system in which pressing a button launches an air - to - air missile    Navigation controller for an autonomous weed  killer robot    Console hockey game  Hard   Missing the deadline to launch the missile within a speciﬁ ed time after pressing the button may cause the target to be missed, which will result in catastrophe   Firm  Missing a few navigation deadlines causes the robot to veer out from a planned path and damage some crops Soft Missing even several deadlines will only degrade performance FUNDAMENTALS OF REAL-TIME SYSTEMS example, in animated displays, images must be updated at least 30 frames per second to provide continuous motion, because the human eye can resolve updating at a slower rate. In navigation systems, accelerations must be read at a rate that is a function of the maximum velocity of the vehicle, and so on. In some cases, however, real - world systems have deadlines that are imposed on them, and are based on nothing less than guessing or on some forgotten and possibly eliminated requirement. The problem in these cases is that undue constraints may be placed on the systems.This is a primary maxim of real - time systems design — to understand the basis and nature of the timing constraints so that they can be relaxed if necessary. In cost - effective and robust real - time systems, a pragmatic rule of thumb could be: process everything as slowly as possible and repeat tasks as seldom as possible. Many real - time systems utilize global clocks and time - stamping for synchronization, task initiation, and data marking. It must be noted, however, that all clocks keep somewhat inaccurate time — even the ofﬁcial U.S. atomic clock must be adjusted regularly. Moreover, there is an associated quantization error with clocks, which may need to be considered when using them for time - stamping. In addition to the degree of “ real - time ” (i.e., hard, ﬁrm, or soft), also, the punctuality of response times is important in many applications. Hence, we deﬁne the concept of real - time punctuality: Deﬁnition: Real - Time Punctuality Real - time punctuality means that every response time has an average value, tR, with upper and lower bounds of tR +εU and tR −εL, respectively, and εU,εL → 0+ . In all practical systems, the values of  εU and εL are nonzero, though they may be very small or even negligible. The nonzero values are due to cumulative latency and propagation - delay components in real - time hardware and software. Such response times contain jitter within the interval  t ∈ [−εL, +εU ]. Real time punctuality is particularly important in periodically sampled systems with high sampling rates, for example, in video signal processing and software radio. Example: Where a Response Time Comes From An elevator door (Pasanen et al., 1991 ) is automatically operated, and it may have a capacitive safety edge for sensing possible passengers between the closing door blades. Thus, the door blades can be quickly reopened before they touch the passenger and cause discomfort or even threaten the passenger ’ s safety. What is the required system response time from when it recognizes that a passenger is between the closing door blades to the instant when it starts to reopen the door? CONCEPTS AND MISCONCEPTIONS This response time consists of ﬁve independent components (their presumably measured numerical values are for illustration purpose only): Sensor Response Time : tS_min = 5 ms, tS_max = 15 ms, tS_mean = 9 ms. Hardware Response Time : tHW_min = 1 μs, tHW_max = 2 μs, tHW_mean = 1.2 μs. System Software Response Time : tSS_min = 16 μs, tSS_max = 48 μs, tSS_mean = 37 μs. Application Software Response Time : tAS_min = 0.5 μs, tAS_max = 0.5 μs, tAS_mean = 0.5 μs. Door Drive Response Time : tDD_min = 300  ms, tDD_max = 500  ms, tDD_mean = 400  ms. Now, we can calculate the minimum, maximum, and mean values of the composite response time: tmin ≈ 305  ms, tmax ≈ 515  ms, and tmean ≈ 409  ms. Thus, the overall response time is dominated by the door- drive response time containing the required deceleration time of the moving door blades. In software systems, a change in state results in a change in the ﬂow - of - control of the computer program. Consider the ﬂowchart in Figure  1.4 . The decision block represented by the diamond suggests that the stream of program instructions can take one of two alternative paths, depending on the response in question. case, if - then, and while statements in any programming language represent a possible change in ﬂow - of - control. Invocation of procedures in Ada and C represent changes in ﬂow - of - control. In object - oriented Figure 1.4. A partial program ﬂowchart showing a conditional branch as a change in ﬂow of control. FUNDAMENTALS OF REAL-TIME SYSTEMS languages, instantiation of an object or the invocation of a method causes the change in sequential ﬂow - of - control. In general, consider the following deﬁnition. Deﬁ nition: Event Any occurrence that causes the program counter to change nonsequentially is considered a change of ﬂow - of - control, and thus an event. In scheduling theory, the release time of a job is similar to an event. Deﬁ nition: Release Time The release time is the time at which an instance of a scheduled task is ready to run, and is generally associated with an interrupt. Events are slightly different from jobs in that events can be caused by interrupts, as well as branches. An event can be either synchronous or asynchronous. Synchronous events are those that occur at predictable times in the ﬂow - of - control, such as that represented by the decision box in the ﬂowchart of Figure  1.4 . The change in ﬂow - of - control, represented by a conditional branch instruction, or by the occurrence of an internal trap interrupt, can be anticipated. Asynchronous events occur at unpredictable points in the ﬂow - of - control and are usually caused by external sources.A real - time clock that pulses regularly at 5 ms is not a synchronous event. While it represents a periodic event, even if the clock were able to tick at a perfect 5 ms without drift, the point where the tick occurs with the ﬂow - of - control is subject to many factors.These factors include the time at which the clock starts relative to the program and propagation delays in the computer system itself.An engineer can never count on a clock ticking exactly at the rate speciﬁed, and so any clock - driven event must be treated as asynchronous. Events that do not occur at regular periods are called aperiodic. Furthermore, aperiodic events that tend to occur very infrequently are called sporadic.Table 1.2  characterizes a sampling of events. For example, an interrupt generated by a periodic external clock represents a periodic but asynchronous event. A periodic but synchronous event is one TABLE 1.2. Taxonomy of Events and Some Typical Examples Periodic  Aperiodic  Sporadic  Synchronous Asynchronous    Cyclic code    Clock interrupt     Conditional branch    Regular, but not ﬁxed - period interrupt   Divide - by - zero (trap) interrupt   Power - loss alarm   These items will be discussed further in Chapters  2 and 3 . CONCEPTS AND MISCONCEPTIONS represented by a sequence of invocation of software tasks in a repeated, circular fashion. A typical branch instruction that is not part of a code block and that runs repeatedly at a regular rate represents a synchronous but aperiodic event.A branch instruction that happens infrequently, say, on the detection of some exceptional condition, is both sporadic and synchronous. Finally, interrupts that are generated irregularly by an external device are classiﬁ ed as either asynchronous aperiodic or sporadic, depending on whether the interrupt is generated frequently or not with respect to the system clock. In every system, and particularly in an embedded real - time system, maintaining overall control is extremely important. For any physical system, certain states exist under which the system is considered to be out of control; the software controlling such a system must therefore avoid these states. For example, in certain aircraft guidance systems, rapid rotation through a 180 ° pitch angle can cause loss of gyroscopic control. Hence, the software must be able to anticipate and avert all such scenarios. Another characteristic of a software - controlled system is that the processor continues to fetch, decode, and execute instructions correctly from the program area of memory, rather than from data or other unwanted memory regions. The latter scenario can occur in poorly tested systems and is a catastrophe from which there is almost no hope of recovery. Software control of any real - time system and associated hardware is maintained when the next state of the system, given the current state and a set of inputs, is predictable. In other words, the goal is to anticipate how a system will behave in all possible circumstances. Deﬁnition: Deterministic System A system is deterministic, if for each possible state and each set of inputs, a unique set of outputs and next state of the system can be determined. Event determinism means the next states and outputs of a system are known for each set of inputs that trigger events. Thus, a system that is deterministic is also event deterministic. Although it would be difﬁcult for a system to be deterministic only for those inputs that trigger events, this is plausible, and so event determinism may not imply determinism. It is interesting to note that while it is a signiﬁcant challenge to design systems that are completely event deterministic, and as mentioned, it is possible to inadvertently end up with a system that is nondeterministic, it is deﬁ nitely hard to design systems that are deliberately nondeterministic. This situation arises from the utmost difﬁculties in designing perfect random number generators. Such deliberately nondeterministic systems would be desirable, for example, as casino gaming machines. Finally, if in a deterministic system the response time for each set of outputs is known, then the system also exhibits temporal determinism. FUNDAMENTALS OF REAL-TIME SYSTEMS A side beneﬁt of designing deterministic systems is that guarantees can be given that the system will be able to respond at any time, and in the case of temporally deterministic systems, when they will respond. This fact reinforces the association of  “ control ” with real - time systems. The ﬁnal and truly important term to be deﬁned is a critical measure of real - time system performance. Because the central processing unit  ( CPU ) continues to fetch, decode, and execute instructions as long as power is applied, the CPU will more or less frequently execute either no - ops or instructions that are not related to the fulﬁllment of a speciﬁc deadline (e.g., noncritical “ housekeeping ” ). The measure of the relative time spent doing nonidle processing indicates how much real - time processing is occurring. Deﬁnition: CPU  Utilization Factor The CPU utilization or time - loading factor, U, is a relative measure of the nonidle processing taking place. A system is said to be time - overloaded if  U > 100%. Systems that are too highly utilized are problematic, because additions, changes, or corrections cannot be made to the system without risk of time - overloading. On the other hand, systems that are not sufﬁciently utilized are not necessarily cost - effective, because this implies that the system was overengineered and that costs could likely be reduced with less expensive hardware. While a utilization of 50% is common for new products, 80% might be acceptable for systems that do not expect growth. However, 70% as a target for  U is one of the most celebrated and potentially useful results in the theory of real - time systems where tasks are periodic and independent — a result that will be examined in Chapter  3 . Table  1.3 gives a summary of certain CPU utilizations and typical situations in which they are associated. U is calculated by summing the contribution of utilization factors for each (periodic or aperiodic) task. Suppose a system has  n ≥ 1 periodic tasks, each with an execution period of pi, and hence, execution frequency, fi = 1/pi. If task i is known to have (or has been estimated to have) a worst- case execution time of ei, then the utilization factor, ui, for task  i is  TABLE 1.3. CPU Utilization (%) Zones    Utilization (%)      Zone Type      Typical Application   <26    Unnecessarily safe     Various   26 – 50    Very safe     Various   51 – 68  Safe    Various   69    Theoretical limit     Embedded systems   70 – 82  Questionable    Embedded systems   83 – 99  Dangerous    Embedded systems   100  Critical    Marginally stressed systems   >100  Overloaded    Stressed systems   CONCEPTS AND MISCONCEPTIONS u =e pi. (1.1)ii Furthermore, the overall system utilization factor is nn pi. (1.2)U = ui = ei∑∑ i=1 i=1 Note that the deadline for a periodic task i, di, is a critical design factor that is constrained by ei. The determination of  ei, either prior to, or after the code has been written, can be extremely difﬁcult, and often impossible, in which case estimation or measuring must be used. For aperiodic and sporadic tasks, ui is calculated by assuming a worst - case execution period, usually the minimum possible time between corresponding event occurrences. Such approximations can inﬂate the utilization factor unnecessarily or lead to overconﬁ dence because of the tendency to “ not worry ” about its excessive contribution. The danger is to discover later that a higher frequency of occurrence than budgeted has led to a time - overload and system failure. The utilization factor differs from CPU throughput, which is a measure of the number of machine - language instructions per second that can be processed based on some predetermined instruction mix.This type of measurement is typically used to compare CPU throughput for a particular application. Example: Calculation of the  CPU  Utilization Factor An individual elevator controller in a bank of high - rise elevators has the following software tasks with execution periods of pi and worst - case execution times of ei, i ∈ {1, 2, 3, 4}: Task 1 : Communicate with the group dispatcher (19.2 K bit/s data rate and a proprietary communications protocol); p1 = 500 ms, e1 = 17 ms. Task 2 : Update the car position information and manage ﬂoor - to - ﬂ oor runs, as well as door control; p2 = 25 ms, e2 = 4 ms. Task 3 : Register and cancel car calls; p3 = 75 ms, e3 = 1 ms. Task 4 : Miscellaneous system supervisions; p4 = 200 ms, e4 = 20 ms. What is the overall CPU utilization factor? 4 174120U =∑ei pi = +++ ≈031. i=1 500 25 75 200 Hence, the utilization percentage is 31%, which belongs to the “ very safe ” zone of Table  1.3 . FUNDAMENTALS OF REAL-TIME SYSTEMS The choice of task deadlines, estimation and reduction of execution times, and other factors that inﬂuence CPU utilization will be discussed in Chapter 7 . 1.1.2   Usual Misconceptions As a part of truly understanding the nature of real - time systems, it is important to address a number of frequently cited misconceptions.These are summarized as follows: 1.  Real - time systems are synonymous with  “ fast ” systems. 2.  Rate - monotonic analysis has solved  “ the real - time problem. ” 3.  There are universal,widely accepted methodologies for real - time systems speciﬁcation and design. 4. There is no more a need to build a real - time operating system, because many commercial products exist. 5.  The study of real - time systems is mostly about scheduling theory. The ﬁrst misconception, that real - time systems must be fast, arises from the fact that many hard real - time systems indeed deal with deadlines in the tens of milliseconds, such as the aircraft navigation system. In a typical food industry application, however, pasta - sauce jars can move along the conveyor belt past a ﬁlling point at a rate of one every ﬁve seconds. Furthermore, the airline reservation system could have a deadline of 15 seconds. These latter deadlines are not particularly fast, but satisfying them determines the success or failure of the system. The second misconception is that rate - monotonic systems provide a simple recipe for building real - time systems. Rate - monotonic systems — a periodic system in which interrupt (or software task) priorities are assigned such that the faster the rate of execution, the higher the priority — have received a lot of attention since the 1970s. While they provide valuable guidance in the design of real - time systems, and while there is abundant theory surrounding them, they are not a panacea. Rate - monotonic systems will be discussed in great detail in Chapter 3 . What about the third misconception? Unfortunately, there are no universally accepted and infallible methods for the speciﬁcation and design of real time systems. This is not a failure of researchers or the software industry, but is because of the difﬁ culty of discovering universal solutions for this demanding ﬁeld. After nearly 40 years of research and development, there is still no methodology available that answers all of the challenges of real - time speciﬁ cation and design all the time and for all applications. The fourth misconception is that there is no more a need to build a real time operating system from scratch.While there are a number of cost - effective, popular, and viable commercial real - time operating systems, these, too, are not MULTIDISCIPLINARY DESIGN CHALLENGES a panacea. Commercial solutions have certainly their place, but choosing when to use an off - the - shelf solution and choosing the right one are challenges that will be considered in Chapter 3 . Finally, while it is scholarly to study scheduling theory, from an engineering standpoint, most published results require impractical simpliﬁ cations and clairvoyance in order to make the theory work. Because this is a textbook for practicing engineers, it avoids any theoretical results that resort to these measures. 1.2   MULTIDISCIPLINARY DESIGN CHALLENGES The study of real - time systems is a truly multidimensional subdiscipline of computer systems engineering that is strongly inﬂuenced by control theory, operations research, and, naturally, software engineering. Figure  1.5 depicts some of the disciplines of computer science, electrical engineering, systems engineering, and applied statistics that affect the design and analysis of real - time systems. Nevertheless, those representative disciplines are not the only ones having a relationship with real - time systems. Because real - time systems engineering is so multidisciplinary, it stands out as a fascinating study area with a rich set of design challenges. Although the fundamentals of real time systems are well established and have considerable permanence, real time systems is a lively developing area due to evolving CPU architectures, distributed system structures, versatile wireless networks, and novel applications, for instance. Figure 1.5. A variety of disciplines that affect real - time systems engineering. FUNDAMENTALS OF REAL-TIME SYSTEMS 1.2.1   Inﬂ uencing Disciplines The design and implementation of real - time systems requires attention to numerous practical issues. These include: • The selection of hardware and system software, and evaluation of the trade - off needed for a competitive solution, including dealing with distributed computing systems and the issues of concurrency and synchronization. •   Speciﬁcation and design of real - time systems, as well as correct and inclusive representation of temporal behavior. • Understanding the nuances of the high - level programming language(s) and the real - time implications resulting from their optimized compilation into machine - language code. •   Optimizing (with application - speciﬁc objectives) of system fault tolerance and reliability through careful design and analysis. • The design and administration of adequate tests at different levels of hierarchy, and the selection of appropriate development tools and test equipment. • Taking advantage of open systems technology and interoperability. An open system is an extensible collection of independently written applications that cooperate to function as an integrated system. For example, several versions of the open operating system, Linux, have emerged for use in various real - time applications (Abbott, 2006 ). Interoperability can be measured in terms of compliance with open system standards, such as the real - time  CORBA  ( common object request broker architecture ) standard (Fay - Wolfe et al., 2000 ). • Finally, estimating and measuring response times and (if needed) reducing them. Performing a schedulability analysis, that is, determining and guaranteeing deadline satisfaction, a priori. Obviously, the engineering techniques used for hard real - time systems can be used in the engineering of all other types of systems as well, with an accompanying improvement of performance and robustness. This alone is a signiﬁ cant reason to study the engineering of real - time systems. 1.3   BIRTH AND EVOLUTION OF REAL - TIME SYSTEMS The history of real - time systems, as characterized by important developments in the United States, is tied inherently to the evolution of the computer. Modern real - time systems, such as those that control nuclear power plants, military weapons systems, or medical monitoring equipment, are sophisticated, yet many still exhibit characteristics of those pioneering systems developed in the 1940s through the 1960s. BIRTH AND EVOLUTION OF REAL-TIME SYSTEMS 1.3.1   Diversifying Applications Embedded real - time systems are so pervasive and ubiquitous that they are even found in household appliances, sportswear, and toys. A small sampling of real - time domains and corresponding applications is given in Table  1.4 . An excellent example of an advanced real - time system is the Mars Exploration Rover of NASA shown in Figure  1.6 . It is an autonomous system with extreme reliability requirements; it receives commands and sends measurement data over radio - communications links; and performs its scientiﬁc missions with the aid of multiple sensors, processors, and actuators. In the introductory paragraphs of this chapter, some real - time systems were mentioned. The following descriptions provide more details for each system, while others provide additional examples. Clearly, these descriptions are not rigorous speciﬁcations.The process of specifying real - time systems unambiguously but concisely is discussed in Chapter 5 . Consider the inertial measurement system for an aircraft. The software speciﬁcation states that the software will receive  x, y, and z accelerometer pulses at a 10 ms rate from special hardware. The software will determine the acceleration components in each direction, and the corresponding roll, pitch, and yaw of the aircraft. The software will also collect other information, such as temperature at a 1 - second rate. The task of the application software is to compute the actual velocity vector based on the current orientation, accelerometer readings, and various compensation factors (such as for temperature effects) at a 40 ms rate. The system is to output true acceleration, velocity, and position vectors to a pilot ’s display every 40 ms, but using a different clock.  TABLE 1.4.  Typical Real - Time Domains and Diverse Applications Domain  Applications  Aerospace    Flight control   Navigation    Pilot interface   Civilian    Automotive systems     Elevator control     Trafﬁc light control  Industrial    Automated inspection     Robotic assembly line     Welding control   Medical  Intensive care monitors  Magnetic resonance imaging    Remote surgery   Multimedia    Console games     Home theaters   Simulators  FUNDAMENTALS OF REAL-TIME SYSTEMS Figure 1.6. Mars Exploration Rover; a solar- powered, autonomous real - time system with radio - communications links and a variety of sensors and actuators. Photo courtesy of NASA. These tasks execute at four different rates in the inertial measurement system, and need to communicate and synchronize. The accelerometer readings must be time - relative or correlated; that is, it is not allowed to mix an x accelerometer pulse of discrete time instant k with y and z pulses of instant k + 1. These are critical design issues for this system. Next, consider a monitoring system for a nuclear power plant that will be handling three events signaled by interrupts.The ﬁrst event is triggered by any of several signals at various security points, which will indicate a security breach. The system must respond to this signal within one second. The second and most important event indicates that the reactor core has reached an overtemperature.This signal must be dealt with within 1 millisecond (1 ms). Finally, an operator ’s display is to be updated at approximately 30 times per second. The nuclear- power- plant system requires a reliable mechanism to ensure that the “ meltdown imminent ” indicator can interrupt any other processing with minimal latency. As another example, recall the airline reservation system mentioned earlier. Management has decided that to prevent long lines and customer dissatisfaction, turnaround time for any transaction must be less than 15 seconds, and no overbooking will be permitted. At any time, several travel agents may try to access the reservations database and perhaps book the same ﬂ ight simultaneously. Here, effective record - locking and secure communications mechanisms BIRTH AND EVOLUTION OF REAL-TIME SYSTEMS are needed to protect against the alteration of the database containing the reservation information by more than one clerk at a time. Now, consider a real - time system that controls all phases of the bottling of jars of pasta sauce as they travel along a conveyor belt. The empty jars are ﬁrst microwaved to disinfect them. A mechanism ﬁlls each jar with a precise serving of speciﬁc sauce as it passes beneath. Another station caps the ﬁ lled bottles. In addition, there is an operator ’s display that provides an animated rendering of the production line activities. There are numerous events triggered by exceptional conditions, such as the conveyor belt jamming and a bottle overﬂowing or breaking. If the conveyor belt travels too fast, the bottle will move past its designated station prematurely. Therefore, there is a wide range of events, both synchronous and asynchronous, to be dealt with. As a ﬁnal example, consider a system used to control a set of trafﬁ c lights at a four- way trafﬁc intersection (north - , south - , east - , and west - bound trafﬁ c). This system controls the lights for vehicle and pedestrian trafﬁ c at a four- way intersection in a busy city like Philadelphia. Input may be taken from cameras, emergency - vehicle transponders, push buttons, sensors under the ground, and so on. The trafﬁc lights need to operate in a synchronized fashion, and yet react to asynchronous events — such as a pedestrian pressing a button at a crosswalk. Failure to operate in a proper fashion can result in automobile accidents and even fatalities. The challenge presented by each of these systems is to determine the appropriate design approach with respect to the multidisciplinary issues discussed in Section 1.2 . 1.3.2   Advancements behind Modern Real - Time Systems Much of the theory of real - time systems is derived from the surrounding disciplines shown in Figure  1.5 . In particular, certain aspects of operations research (i.e., scheduling), which emerged in the late 1940s, and queuing theory in the early 1950s, have inﬂuenced most of the more theoretical results. Martin published one of the ﬁrst and certainly the most inﬂ uential early book on real - time systems (Martin, 1967 ). Martin ’s book was soon followed by several others (e.g., Stimler, 1969 ), and the inﬂuence of operations research and queuing theory can be seen in these works. It is also educational to study these texts in the context of the great limitations of the hardware of the time. In 1973, Liu and Layland published their seminal work on rate - monotonic theory (Liu and Layland, 1973 ). Over the last nearly 40 years, signiﬁ cant reﬁ nement of this theory has made it a practical theory for use in designing real - time systems. The 1980s and 1990s saw a proliferation of theoretical work on improving predictability and reliability of real - time systems, and on solving problems related to multitasking systems. Today, a rather small group of experts continues to study pure issues of scheduling and performance analysis, while a larger group of generalist systems engineers tackles broader issues relating to the FUNDAMENTALS OF REAL-TIME SYSTEMS implementation of practical systems. An important paper by Stankovic et al. (Stankovic et al.,1995 ) described some of the difﬁculties in conducting research on real - time systems — even with signiﬁcant restriction of the system, most problems relating to scheduling are too difﬁcult to solve by analytic techniques. Instead of any single “ groundbreaking ” technology, the new millennium saw a number of important advancements in hardware, viable open - source software for real - time systems, powerful commercial design and implementation tools, and expanded programming language support.These advancements have in some ways simpliﬁed the construction and analysis of real - time systems but on the other hand introduced new problems because of the complexities of systems interactions and the masking of many of the underlying subtleties of time constraints. The origin of the term  real- time computing is unclear. It was probably ﬁ rst used either with project Whirlwind, a ﬂight simulator developed by IBM for the U.S. Navy in 1947, or with SAGE, the Semiautomatic Ground Environment air defense system developed for the U.S. Air Force in the late 1950s. Both of these projects qualify as real - time systems even by today ’s deﬁnitions. In addition to its real - time contributions, the Whirlwind project included the ﬁ rst use of ferrite core memory ( “ fast ” ) and a form of high - level language compiler that predated Fortran. Other early real - time systems were used for airline reservations, such as SABRE (developed for American Airlines in 1959), as well as for process control, but the advent of the national space program provided even greater opportunities for the development of more advanced real - time systems for spacecraft control and telemetry. It was not until the 1960s that rapid development of such systems took place, and then only as signiﬁ cant nonmilitary interest in real - time systems become coupled with the availability of equipment adapted to real - time processing. Low - performance processors and particularly slow and small memories handicapped many of the earliest systems. In the early 1950s, the asynchronous interrupt was introduced and later incorporated as a standard feature in the Univac Scientiﬁc 1103A.The middle 1950s saw a distinct increase in the speed and complexity of large - scale computers designed for scientiﬁ c computation, without an increase in physical size. These developments made it possible to apply real - time computation in the ﬁeld of control systems. Such hardware improvements were particularly noticeable in IBM ’s development of SAGE. In the 1960s and 1970s, advances in integration levels and processing speeds enhanced the spectrum of real - time problems that could be solved. In 1965 alone, it was estimated that more than 350 real - time process control systems existed (Martin, 1967 ). The 1980s and 1990s have seen, for instance, distributed systems and non von Neumann architectures utilized in real - time applications. Finally, the late 1990s and early 2000s have set new trends in real - time embedded systems in consumer products and Web - enabled devices.The availSUMMARY ability of compact processors with limited memory and functionality has rejuvenated some of the challenges faced by early real - time systems designers. Fortunately, around 60 years of experience is now available to draw upon. Early real - time systems were written directly in microcode or assembly language, and later in higher- level languages. As previously noted, Whirlwind used an early form of high - level language called an algebraic compiler to simplify coding. Later systems employed Fortran, CMS - 2, and JOVIAL, the preferred languages in the U.S. Army, Navy, and Air Force, respectively. In the 1970s, the Department of Defense  ( DoD ) mandated the development of a single language that all military services could use, and that provided high - level language constructs for real - time programming. After a careful selection and reﬁnement process, the Ada language appeared as a standard in 1983. Shortfalls in the language were identiﬁed, and a new, improved version of the language, Ada 95, appeared in 1995. Today, however, only a small number of systems are developed in Ada. Most embedded systems are written in C or C++. In the last 10 years, there has been a remarkable increase in the use of object - oriented methodologies, and languages like C++ and Java in embedded real - time systems.The real - time aspects of programming languages are discussed later in Chapter 4 . The ﬁrst commercial operating systems were designed for the early mainframe computers. IBM developed the ﬁrst real - time executive, the Basic Executive, in 1962, which provided diverse real - time scheduling. By 1963, the Basic Executive II had disk - resident system and user programs. By the mid - 1970s, more affordable minicomputer systems could be found in many engineering environments. In response, a number of important real time operating systems were developed by the minicomputer manufacturers. Notable among these were the Digital Equipment Corporation  ( DEC ) family of real - time multitasking executives  ( RSX ) for the PDP - 11, and Hewlett Packard ’s  Real - Time Executive  ( RTE ) series of operating systems for its HP 2000 product line. By the late 1970s and early 1980s, the ﬁrst real - time operating systems for microprocessor- based applications appeared. These included RMX 80, MROS 68K, VRTX, and several others. Over the past 30 years, many commercial real - time operating systems have appeared, and many have disappeared. A selective summary of landmark events in the ﬁeld of real - time systems in the United States is given in Table 1.5 . 1.4   SUMMARY The deep - going roots of real - time systems were formed during the historical years of computers and computing — before the microprocessor era. However, the ﬁrst “ boom ” of real - time systems took place around the beginning of 1980s, when appropriate microprocessors and real - time operating systems became FUNDAMENTALS OF REAL-TIME SYSTEMS TABLE 1.5. Landmarks in Real - Time Systems History in the United States    Year   Landmark  Developer  Development  Innovations  1947    Whirlwind   IBM    Flight simulator     Ferrite core  memory  ( “ fast ” ),  high - level  language  1957    SAGE   IBM    Air defense     Designed for  real - time  1958    Scientiﬁ c  Univac    General purpose   Asynchronous  1103A interrupt  1959  SABRE  IBM    Airline reservation   “ Hub - go - ahead ”  policy   1962  Basic  IBM    General purpose     Diverse real - time  Executive scheduling  1963  Basic  IBM    General purpose   Disk - resident  Executive II  system/user  programs  1970s    RSX, RTE     DEC, HP   Real - time    Hosted by  operating  minicomputers systems  1973  Rate    Liu and  Fundamental    Upper bound on  monotonic  Layland theory utilization for  system schedulable  systems  1970s  RMX - 80,    Various   Real - time    Hosted by  and  MROS 68K,  operating  microprocessors 1980s VRTX, etc. systems  1983    Ada 83     U.S. DoD  Programming    For mission  language  critical  embedded  systems  1995    Ada 95   Community  Programming    Improved version  language of Ada 83  2000s  –  –    Various advances    A continuously  in hardware,  growing range  open - source, and  of innovative  commercial  applications  system software  that can be  and tools  “ real - time ”  available (to be used in embedded systems) for an enormous number of electrical, systems, as well as mechanical and aerospace engineers.These practicing engineers did not have much software or even computer education, and, thus, the initial learning path was laborious in most ﬁelds of industry. In those early times, the majority of real - time operating systems and communications protoSUMMARY cols were proprietary designs — applications people were developing both system and application software themselves. But the situation started to improve with the introduction of more effective high - level language compilers, software debugging tools, communications standards, and, gradually, also methodologies and associated tools for professional software engineering. What is left from those pioneering years approximately 30 years ago? Well, the foundation of real - time systems is still remarkably the same. The core issues, such as the different degrees of real - time and deterministic requirements, as well as real - time punctuality, are continuing to set major design challenges. Besides, the basic techniques of multitasking and scheduling, and the accompanying inter- task communication and synchronization mechanisms, are used even in modern real - time applications. Hence, real - time systems knowledge has a long lifetime. Nonetheless, much fruitful development is taking place in real - time systems engineering worldwide: new speciﬁ cation and design methods are introduced; innovative processor and system architectures become available and practical; ﬂexible and low - cost wireless networks gain popularity; and numerous novel applications appear continuously, for example, in the ﬁeld of ubiquitous computing. We can fairly conclude that real - time systems engineering is a sound and timely topic for junior- senior level, graduate, and continuing education; and it offers growing employment potential in various industries. In the coming chapters, we will cover a broad range of vital themes for practicing engineers (see Fig. 1.7 ). While the emphasis is on software issues, the fundamentals of real - time hardware are carefully outlined as well. Our aim is to provide a comprehensive text to be used also in industrial settings for new real - time system designers, who need to get “ up to speed ” quickly. That aim is highlighted in this fourth edition of Real - Time Systems Design and Analysis, with the descriptive subtitle Tools for the Practitioner. Figure 1.7. Composition of this unique text from nine complementary chapters. FUNDAMENTALS OF REAL-TIME SYSTEMS 1.5 EXERCISES 1.1. Consider a payroll processing system for an elevator company. Describe three different scenarios in which the system can be justiﬁed as hard, ﬁrm, or soft real - time. 1.2. Discuss whether the following are hard, ﬁrm, or soft real - time systems: (a)  The Library of Congress print - manuscript database system. (b) A police database that provides information on stolen automobiles. (c) An automatic teller machine in a shopping mall. (d) A coin - operated video game in some amusement park. (e)  A university grade - processing system. (f) A computer- controlled routing switch used at a telephone company branch exchange. 1.3. Consider a real - time weapons control system aboard a ﬁ ghter aircraft. Discuss which of the following events would be considered synchronous and which would be considered asynchronous to the real - time computing system. (a)  A 5 - ms, externally generated clock interrupt. (b)  An illegal - instruction - code (trap) interrupt. (c)  A built - in - test memory failure. (d) A discrete signal generated by the pilot pushing a button to ﬁ re a missile. (e)  A discrete signal indicating “ low on fuel. ” 1.4. Describe a system that is completely nonreal - time, that is, there are no bounds whatsoever for any response time. Do such systems exist in reality? 1.5. For the following systems concepts, ﬁll in the cells of Table  1.2 with descriptors for possible events. Estimate event periods for the periodic events. (a) Elevator group dispatcher: this subsystem makes optimal hall - call allocation for a bank of high - speed elevators that service a 40 - story building in a lively city like Louisville. (b) Automotive control: this on - board crash avoidance system uses data from a variety of sensors and makes decisions and affects behavior to avoid collision, or protect the occupants in the event of an imminent collision. The system might need to take control of the automobile from the driver temporarily. 1.6. For the real - time systems in Exercise 1.2, what are reasonable response times for all those events? REFERENCES 1.7. For the example systems introduced (inertial measurement, nuclear-power- plant monitoring, airline reservation, pasta bottling, and trafﬁ c light control) enumerate some possible events and note whether they are periodic, aperiodic, or sporadic. Discuss reasonable response times for the events. 1.8. In the response - time example of Section  1.1 , the time from observing a passenger between the closing door blades and starting to reopen the elevator door varies between 305 and 515 ms. How could you further justify if these particular times are appropriate for this situation? 1.9. A control system is measuring its feedback quantity at the rate of 100 μs. Based on the measurement, a control command is computed by a heuristic algorithm that uses complex decision making. The new command becomes available 27 – 54  μs (rather evenly distributed) after each sampling moment. This considerable jitter introduces harmful distortion to the controller output. How could you avoid (reduce) such a jitter? What (if any) are the drawbacks of your solution? 1.10. Reconsider the CPU utilization factor example of Section 1.1 . How short could the execution period of Task 1, e1, be made to maintain the CPU utilization zone no worse than  “ questionable ” (Table 1.3 )? REFERENCES     D. Abbott, Linux for Embedded and Real - Time Applications , 2nd Edition . Burlington, MA : Newnes , 2006 .    T. N. B. Anh and   S. - L. Tan  , “Real - time operating systems for small microcontrollers , ” IEEE Micro , 29 ( 5 ), pp. 30–45 , 2009 .    V.Fay - Wolfe   et al., “  Real - time CORBA , ”IEEE Transactions on Parallel and Distributed Systems, 11 ( 10 ), pp. 1073–1089 , 2000 .    C. L. Liu   and   J. W. Layland, “Scheduling algorithms for multi - programming in a hard real - time environment , ” Journal of the ACM, 20 ( 1 ), pp. 46–61 , 1973 .    J. Martin, Design of Real - Time Computer Systems. Englewood Cliffs, NJ : Prentice - Hall , 1967 .    J. Pasanen,  P. Jahkonen  ,  S. J. Ovaska,  H. Tenhunen  ,and   O. Vainio,“  An integrated digital motion control unit , ” IEEE Transactions on Instrumentation and Measurement,  40 ( 3 ), pp. 654–657 , 1991 .    J. A. Stankovic,  M. Spuri  ,  M. Di Natale, and   G. C. Buttazzo, “Implications of classical scheduling results for real - time systems , ” IEEE Computer , 28 ( 6 ), pp. 16–25 , 1995 .    S. Stimler, Real - Time Data - Processing Systems. New York : McGraw - Hill , 1969 .    P. Vernon  , “Systems in engineering , ” IEE Review , 35 ( 10 ), pp. 383–385 , 1989 . A Tutorial on Uppaal 4.0 Updated November 28, 2006 Gerd Behrmann, Alexandre David, and Kim G. Larsen Department of Computer Science, Aalborg University, Denmark {behrmann,adavid,kgl}@cs.auc.dk. Abstract. This is a tutorial paper on the tool Uppaal. Its goal is to be a short introduction on the ﬂavour of timed automata implemented in the tool, to present its interface, and to explain how to use the tool. The contribution of the paper is to provide reference examples and modelling patterns. 1 Introduction Uppaal is a toolbox for veriﬁcation of real-time systems jointly developed by Uppsala University and Aalborg University. It has been applied successfully in case studies ranging from communication protocols to multimedia applications [35,55,24,23,34,43,54,44,30]. The tool is designed to verify systems that can be modelled as networks of timed automata extended with integer variables, structured data types, user deﬁned functions, and channel synchronisation. The ﬁrst version of Uppaal was released in 1995 [52]. Since then it has been in constant development [21,5,13,10,26,27]. Experiments and improvements include data structures [53], partial order reduction [20], a distributed version of Uppaal [17,9], guided and minimal cost reachability [15,51,16], work on UML Statecharts [29], acceleration techniques [38], and new data structures and memory reductions [18,14]. Version 4.0 [12] brings symmetry reduction [36], the generalised sweep-line method [49], new abstraction techniques [11], priorities [28], and user deﬁned functions to the mainstream. Uppaal has also generated related Ph.D. theses [50,57,45,56,19,25,32,8,31]. It features a Java user interface and a veriﬁcation engine written in C++ . It is freely available at http://www.uppaal.com/. This tutorial covers networks of timed automata and the ﬂavour of timed automata used in Uppaal in section 2. The tool itself is described in section 3, and three extensive examples are covered in sections 4, 5, and 6. Finally, section 7 introduces common modelling patterns often used with Uppaal. 2 Timed Automata in Uppaal The model-checker Uppaal is based on the theory of timed automata [4] (see [42] for automata theory) and its modelling language o ers additional features such as bounded integer variables and urgency. The query language of Uppaal, used to specify properties to be checked, is a subset of TCTL (timed computation tree logic) [39,3]. In this section we present the modelling and the query languages of Uppaal and we give an intuitive explanation of time in timed automata. 2.1 The Modelling Language Networks of Timed Automata A timed automaton is a ﬁnite-state machine extended with clock variables. It uses a dense-time model where a clock variable evaluates to a real number. All the clocks progress synchronously. In Uppaal, a system is modelled as a network of several such timed automata in parallel. The model is further extended with bounded discrete variables that are part of the state. These variables are used as in programming languages: They are read, written, and are subject to common arithmetic operations. A state of the system is deﬁned by the locations of all automata, the clock values, and the values of the discrete variables. Every automaton may ﬁre an edge (sometimes misleadingly called a transition) separately or synchronise with another automaton1 , which leads to a new state. Figure 1(a) shows a timed automaton modelling a simple lamp. The lamp has three locations: off, low, and bright. If the user presses a button, i.e., synchronises with press?, then the lamp is turned on. If the user presses the button again, the lamp is turned o . However, if the user is fast and rapidly presses the button twice, the lamp is turned on and becomes bright. The user model is shown in Fig. 1(b). The user can press the button randomly at any time or even not press the button at all. The clock y of the lamp is used to detect if the user was fast (y< 5) or slow (y> = 5). press? (a) Lamp. (b) User. Fig. 1. The simple lamp example. We give the basic deﬁnitions of the syntax and semantics for the basic timed automata. In the following we will skip the richer ﬂavour of timed automata supported in Uppaal, i.e., with integer variables and the extensions of urgent and committed locations. For additional information, please refer to the help 1 or several automata in case of broadcast synchronisation, another extension of timed automata in Uppaal. 2 menu inside the tool. We use the following notations: C is a set of clocks and B (C ) is the set of conjunctions over simple conditions of the form x ⊲⊳c or x − y ⊲⊳c, where x, y ∈ C , c ∈ N and ⊲⊳∈{<, ≤, = , ≥,>}. A timed automaton is a ﬁnite directed graph annotated with conditions over and resets of non-negative real valued clocks. Deﬁnition 1 (Timed Automaton (TA)). A timed automaton is a tuple (L, l0 , C, A, E, I ), where L is a set of locations, l0 ∈ L is the initial location, C is the set of clocks, A is a set of actions, co-actions and the internal τ -action, E ⊆ L × A × B (C ) × 2C × L is a set of edges between locations with an action, a guard and a set of clocks to be reset, and I : L → B (C ) assigns invariants to locations. &#3; In the previous example on Fig. 1, y:=0 is the reset of the clock y , and the labels press? and press! denote action–co-action (channel synchronisations here). We now deﬁne the semantics of a timed automaton. A clock valuation is a function u : C → R≥0 from the set of clocks to the non-negative reals. Let RC be the set of all clock valuations. Let u0 (x)=0 for all x ∈ C . We will abuse the notation by considering guards and invariants as sets of clock valuations, writing u ∈ I (l ) to mean that u satisﬁes I (l ). AB action transition AB x<3 <B,x=1> &#1;&#1;&#1;&#1;&#1;&#1;&#1;delay(+1) transition&#1;&#1;&#1;&#1;&#1;&#1;&#1; x<3 action A BA Bstate: <A,x=1> transition &#1;&#1;&#1;&#1;&#1;&#1;&#1;&#1;&#1;&#1;&#1;&#1;&#1;&#1; &#1;&#1;&#1;&#1;&#1;&#1;&#1;OK&#1;&#1;&#1;&#1; &#1;&#1;&#1;&#1;&#1;&#1;&#1; &#1;&#1;&#1;&#1;&#1;&#1;&#1; &#1;&#1;&#1;&#1;&#1;&#1;&#1; &#1;&#1;&#1;&#1;&#1;&#1;&#1; x<3 x<3 &#1;&#1;&#1;&#1;&#1;&#1;&#1; &#1;&#1;&#1;&#1;&#1;&#1;&#1; <A,x=2> <A,x=3>&#1;&#1;&#1;&#1;&#1;&#1;&#1; &#1;&#1;&#1;&#1;&#1;&#1;&#1; invalid &#1;&#1;&#1;&#1;&#1;&#1;&#1;&#1;&#1;&#1;&#1;&#1;&#1;&#1;&#1;&#1;&#1;&#1; delay(+2) transition &#1;&#1;&#1;&#1;&#1;&#1;&#1;&#1;&#1;&#1;&#1; &#1;&#1;&#1;&#1;&#1;&#1;&#1; AB&#1;&#1;&#1;&#1;&#1;&#1;&#1; action &#1;&#1;&#1;&#1;&#1;&#1;&#1;&#1;&#1;&#1;&#1; &#1;&#1;&#1;&#1;&#1;&#1;&#1;&#1;&#1;&#1;&#1; &#1;&#1;&#1;&#1;&#1;&#1;&#1;&#1;&#1;&#1;&#1;&#1;&#1;&#1;&#1;&#1;&#1;&#1; &#1;&#1;&#1;&#1;&#1;&#1;&#1;transition &#1;&#1;&#1;&#1;&#1;&#1;&#1;&#1;&#1;&#1;&#1; &#1;&#1;&#1;&#1;&#1;&#1;&#1;&#1;&#1;&#1;&#1; &#1;&#1;&#1;&#1;&#1;&#1;&#1;&#1;&#1;&#1;&#1; &#1;&#1;&#1;&#1;&#1;&#1;&#1;&#1;&#1;&#1;&#1; &#1;&#1;&#1;&#1;&#1;&#1;&#1;&#1;&#1;&#1;&#1;x<3 &#1;&#1;&#1;&#1;&#1;&#1;&#1;&#1;&#1;&#1;&#1; &#1;&#1;&#1;&#1;&#1;&#1;&#1;&#1;&#1;&#1;&#1; &#1;&#1;&#1;&#1;&#1;&#1;&#1;&#1;&#1;&#1;&#1; &#1;&#1;&#1;&#1;&#1;&#1;&#1;&#1;&#1;&#1;&#1; &#1;&#1;&#1;&#1;&#1;&#1;&#1; <A,x=3> <A,x=3> invalid state: invariant x<3 violated Fig. 2. Semantics of TA: di erent transitions from a given initial state. Deﬁnition 2 (Semantics of TA). Let (L, l0 , C, A, E, I ) be a timed automaton. The semantics is deﬁned as a labelled transition system S, s0 , →, where S ⊆ L × RC is the set of states, s0 =(l0 ,u0 ) is the initial state, and →⊆ S ×(R≥0 ∪A)×S is the transition relation such that: d ′′ ′ – (l, u) −→ (l, u + d) if ∀d :0 ≤ d ≤ d =⇒ u + d ∈ I (l ), and a ′ – (l, u) −→ (l ,u ′) if there exists e =(l, a, g, r, l ′) ∈ E s.t. u ∈ g , ′′ u =[r → 0]u, and u ∈ I (l ′ ), 3 where for d ∈ R≥0 , u + d maps each clock x in C to the value u(x)+ d, and [r → 0]u denotes the clock valuation which maps each clock in r to 0 and agrees with u over C \ r . &#3; Figure 2 illustrates the semantics of TA. From a given initial state, we can choose to take an action or a delay transition (di erent values here). Depending of the chosen delay, further actions may be forbidden. Timed automata are often composed into a network of timed automata over a common set of clocks and actions, consisting of n timed automata Ai = 0(Li,li , C, A, Ei,Ii), 1 ≤ i ≤ n . A location vector is a vector ¯ l =(l1 ,... ,ln). We compose the invariant functions into a common function over location vec′ tors I (¯ l )= ∧iIi(li). We write l ¯[li/li] to denote the vector where the ith element ′ li of ¯ l is replaced by li. In the following we deﬁne the semantics of a network of timed automata. Deﬁnition 3 (Semantics of a network of Timed Automata). Let Ai = 0 00(Li,li , C, A, Ei,Ii) be a network of n timed automata. Let ¯ l0 =(l ... ,l ) be the1 , n initial location vector. The semantics is deﬁned as a transition system S, s0 , →, where S =(L1 × · × Ln) × RC is the set of states, s0 = (¯ l0 ,u0 ) is the initial state, and →⊆ S × S is the transition relation deﬁned by: d ′′ ′ – (¯ l, u) −→ (¯ l, u + d) if ∀d :0 ≤ d ≤ d =⇒ u + d ∈ I (¯ l ). a ˝gr′′ – (¯ l, u) −→ (¯ l[li/li],u ′) if there exists li −−→ li s.t. u ∈ g , ′ ′′ u =[r → 0]u and u ∈ I (¯ l [li/li]). ac?gi ri′′ ′ – (¯ l, u) −→ (¯ l[lj /lj,li/li],u ′) if there exist li −−−→ li and c!gj rj ′ ′ ′′′ lj −−−→ lj s.t. u ∈ (gi ∧ gj ), u =[ri ∪ rj → 0]u and u ∈ I (¯ l [lj /lj,li/li]). &#3; As an example of the semantics, the lamp in Fig. 1 may have the following states (we skip the user): (Lamp.off,y = 0) → (Lamp.off,y = 3) → (Lamp.low,y = 0) → (Lamp.low,y =0.5) → (Lamp.bright,y =0.5) → (Lamp.bright,y =1000) ... Timed Automata in Uppaal The Uppaal modelling language extends timed automata with the following additional features (see Fig. 3: Templates automata are deﬁned with a set of parameters that can be of any type (e.g., int, chan). These parameters are substituted for a given argument in the process declaration. Constants are declared as const name value. Constants by deﬁnition cannot be modiﬁed and must have an integer value. Bounded integer variables are declared as int[min,max] name, where min and max are the lower and upper bound, respectively. Guards, invariants, and assignments may contain expressions ranging over bounded integer variables. The bounds are checked upon veriﬁcation and violating a bound leads to an invalid state that is discarded (at run-time). If the bounds are omitted, the default range of -32768 to 32768 is used. 4 Fig. 3. Declarations of a constant and a variable, and illustration of some of the channel synchronisations between two templates of the train gate example of Section 4, and some committed locations. 5 Binary synchronisation channels are declared as chan c. An edge labelled with c! synchronises with another labelled c?. A synchronisation pair is chosen non-deterministically if several combinations are enabled. Broadcast channels are declared as broadcast chan c. In a broadcast synchronisation one sender c! can synchronise with an arbitrary number of receivers c?. Any receiver than can synchronise in the current state must do so. If there are no receivers, then the sender can still execute the c! action, i.e. broadcast sending is never blocking. Urgent synchronisation channels are declared by preﬁxing the channel declaration with the keyword urgent. Delays must not occur if a synchronisation transition on an urgent channel is enabled. Edges using urgent channels for synchronisation cannot have time constraints, i.e., no clock guards. Urgent locations are semantically equivalent to adding an extra clock x, that is reset on all incoming edges, and having an invariant x<=0 on the location. Hence, time is not allowed to pass when the system is in an urgent location. Committed locations are even more restrictive on the execution than urgent locations. A state is committed if any of the locations in the state is committed. A committed state cannot delay and the next transition must involve an outgoing edge of at least one of the committed locations. Arrays are allowed for clocks, channels, constants and integer variables. They are deﬁned by appending a size to the variable name, e.g. chan c[4]; clock a[2]; int[3,5] u[7];. Initialisers are used to initialise integer variables and arrays of integer variables. For instance, int i = 2; or int i[3] = {1, 2, 3};. Record types are declared with the struct construct like in C. Custom types are deﬁned with the C-like typedef construct. You can deﬁne any custom-type from other basic types such as records. User functions are deﬁned either globally or locally to templates. Template parameters are accessible from local functions. The syntax is similar to C except that there is no pointer. C++ syntax for references is supported for the arguments only. Expressions in Uppaal Expressions in Uppaal range over clocks and integer variables. The BNF is given in Fig. 33 in the appendix. Expressions are used with the following labels: Select A select label contains a comma separated list of name : type expressions where name is a variable name and type is a deﬁned type (built-in or custom). These variables are accessible on the associated edge only and they will take a non-deterministic value in the range of their respective types. Guard A guard is a particular expression satisfying the following conditions: it is side-e ect free; it evaluates to a boolean; only clocks, integer variables, and constants are referenced (or arrays of these types); clocks and clock di erences are only compared to integer expressions; guards over clocks are essentially conjunctions (disjunctions are allowed over integer conditions). A guard may call a side-e ect free function that returns a bool, although clock constraints are not supported in such functions. 6 Synchronisation A synchronisation label is either on the form E xpr ession! or E xpr ession? or is an empty label. The expression must be side-e ect free, evaluate to a channel, and only refer to integers, constants and channels. Update An update label is a comma separated list of expressions with a side-e ect; expressions must only refer to clocks, integer variables, and constants and only assign integer values to clocks. They may also call functions. Invariant An invariant is an expression that satisﬁes the following conditions: it is side-e ect free; only clock, integer variables, and constants are referenced; it is a conjunction of conditions of the form x<e or x<=e where x is a clock reference and e evaluates to an integer. An invariant may call a side-e ect free function that returns a bool, although clock constraints are not supported in such functions. 2.2 The Query Language The main purpose of a model-checker is verify the model w.r.t. a requirement speciﬁcation. Like the model, the requirement speciﬁcation must be expressed in a formally well-deﬁned and machine readable language. Several such logics exist in the scientiﬁc literature, and Uppaal uses a simpliﬁed version of TCTL. Like in TCTL, the query language consists of path formulae and state formulae.2 State formulae describe individual states, whereas path formulae quantify over paths or traces of the model. Path formulae can be classiﬁed into reachability, safety and liveness. Figure 4 illustrates the di erent path formulae supported by Uppaal. Each type is described below. State Formulae A state formula is an expression (see Fig. 33) that can be evaluated for a state without looking at the behaviour of the model. For instance, this could be a simple expression, like i == 7, that is true in a state whenever i equals 7. The syntax of state formulae is a superset of that of guards, i.e., a state formula is a side-e ect free expression, but in contrast to guards, the use of disjunctions is not restricted. It is also possible to test whether a particular process is in a given location using an expression on the form P.l, where P is a process and l is a location. In Uppaal, deadlock is expressed using a special state formula (although this is not strictly a state formula). The formula simply consists of the keyword deadlock and is satisﬁed for all deadlock states. A state is a deadlock state if there are no outgoing action transitions neither from the state itself or any of its delay successors. Due to current limitations in Uppaal, the deadlock state formula can only be used with reachability and invariantly path formulae (see below). Reachability Properties Reachability properties are the simplest form of properties. They ask whether a given state formula, ϕ, possibly can be satisﬁed 2 In contrast to TCTL, Uppaal does not allow nesting of path formulae. 7 Fig. 4. Path formulae supported in Uppaal. The ﬁlled states are those for which a given state formulae ° holds. Bold edges are used to show the paths the formulae evaluate on. by any reachable state. Another way of stating this is: Does there exist a path starting at the initial state, such that ϕ is eventually satisﬁed along that path. Reachability properties are often used while designing a model to perform sanity checks. For instance, when creating a model of a communication protocol involving a sender and a receiver, it makes sense to ask whether it is possible for the sender to send a message at all or whether a message can possibly be received. These properties do not by themselves guarantee the correctness of the protocol (i.e. that any message is eventually delivered), but they validate the basic behaviour of the model. We express that some state satisfying ϕ should be reachable using the path formula E 3 ϕ. In Uppaal, we write this property using the syntax E<> ϕ. Safety Properties Safety properties are on the form: “something bad will never happen”. For instance, in a model of a nuclear power plant, a safety property might be, that the operating temperature is always (invariantly) under a certain threshold, or that a meltdown never occurs. A variation of this property is that “something will possibly never happen”. For instance when playing a game, a safe state is one in which we can still win the game, hence we will possibly not loose. In Uppaal these properties are formulated positively, e.g., something good is invariantly true. Let ϕ be a state formulae. We express that ϕ should be true 3in all reachable states with the path formulae A&#3;ϕ, whereas E &#3;ϕ says that 3 Notice that A&#3;'= ¬E3 ¬' 8 there should exist a maximal path such that ϕ is always true.4 In Uppaal we write A[] ϕ and E[] ϕ, respectively. Liveness Properties Liveness properties are of the form: something will eventually happen, e.g. when pressing the on button of the remote control of the television, then eventually the television should turn on. Or in a model of a communication protocol, any message that has been sent should eventually be received. In its simple form, liveness is expressed with the path formula A3 ϕ, meaning ϕ is eventually satisﬁed.5 The more useful form is the leads to or response property, written ϕψ which is read as whenever ϕ is satisﬁed, then eventually ψ will be satisﬁed, e.g. whenever a message is sent, then eventually it will be received.6 In Uppaal these properties are written as A<> ϕ and ϕ --> ψ , respectively. 2.3 Understanding Time Invariants and Guards Uppaal uses a continuous time model. We illustrate the concept of time with a simple example that makes use of an observer. Normally an observer is an add-on automaton in charge of detecting events without changing the observed system. In our case the clock reset (x:=0) is delegated to the observer for illustration purposes. Figure 5 shows the ﬁrst model with its observer. We have two automata in parallel. The ﬁrst automaton has a self-loop guarded by x>=2, x being a clock, that synchronises on the channel reset with the second automaton. The second automaton, the observer, detects when the self loop edge is taken with the location taken and then has an edge going back to idle that resets the clock x. We moved the reset of x from the self loop to the observer only to test what happens on the transition before the reset. Notice that the location taken is committed (marked c) to avoid delay in that location. The following properties can be veriﬁed in Uppaal (see section 3 for an overview of the interface). Assuming we name the observer automaton Obs, we have: – A[] Obs.taken imply x>=2 : all resets o x will happen when x is above 2. This query means that for all reachable states, being in the location Obs.taken implies that x>=2. – E<> Obs.idle and x>3 : this property requires, that it is possible to reachable state where Obs is in the location idle and x is bigger than 3. Essentially we check that we may delay at least 3 time units between resets. The result would have been the same for larger values like 30000, since there are no invariants in this model. 4 A maximal path is a path that is either inﬁnite or where the last state has no outgoing transitions. 5 Notice that A3 '= ¬E&#3;¬'. 6 Experts in TCTL will recognise that ' is equivalent to A&#3;(' =) A3 ) 9 4 reset? 2idle takenloop x>=2 reset! x:=0 2 4 6 8 "time" (a) Test. (b) Observer. (c) Behaviour: one possible run. Fig. 5. First example with an observer. ‚‚‚‚‚ 2 4 6 8 "time" (a) Test. (b) Updated behaviour with an invariant. Fig. 6. Updated example with an invariant. The observer is the same as in Fig. 5 and is not shown here. We update the ﬁrst model and add an invariant to the location loop, as shown in Fig. 6. The invariant is a progress condition: the system is not allowed to stay in the state more than 3 time units, so that the transition has to be taken and the clock reset in our example. Now the clock x has 3 as an upper bound. The following properties hold: – A[] Obs.taken imply (x>=2 and x<=3) shows that the transition is taken when x is between 2 and 3, i.e., after a delay between 2 and 3. – E<> Obs.idle and x>2 : it is possible to take the transition when x is between 2 and 3. The upper bound 3 is checked with the next property. – A[] Obs.idle imply x<=3 : to show that the upper bound is respected. The former property E<> Obs.idle and x>3 no longer holds. Now, if we remove the invariant and change the guard to x>=2 and x<=3, you may think that it is the same as before, but it is not! The system has no progress condition, just a new condition on the guard. Figure 7 shows what happens: the system may take the same transitions as before, but deadlock may also occur. The system may be stuck if it does not take the transition after 3 time units. In fact, the system fails the property A[] not deadlock. The property A[] Obs.idle imply x<=3 does not hold any longer and the deadlock can also be illustrated by the property A[] x>3 imply not Obs.taken, i.e., after 3 time units, the transition is not taken any more. 10 4 loop 2x>=2 && x<=3 reset! 2 4 6 8 "time" (a) Test. (b) Updated behaviour with a guard and no invariant. Fig. 7. Updated example with a guard and no invariant. S0 S1 S2 S0 S1 S2 Fig. 8. Automata in parallel with normal, urgent and commit states. The clocks are local, i.e., P0.x and P1.x are two di erent clocks. Committed and Urgent Locations There are three di erent types of locations in Uppaal: normal locations with or without invariants (e.g., x<=3 in the previous example), urgent locations, and committed locations. Figure 8 shows 3 automata to illustrate the di erence. The location marked u is urgent and the one marked c is committed. The clocks are local to the automata, i.e., x in P0 is di erent from x in P1. To understand the di erence between normal locations and urgent locations, we can observe that the following properties hold: – E<> P0.S1 and P0.x>0 : it is possible to wait in S1 of P0. – A[] P1.S1 imply P1.x==0 : it is not possible to wait in S1 of P1. An urgent location is equivalent to a location with incoming edges reseting a designated clock y and labelled with the invariant y<=0. Time may not progress in an urgent state, but interleavings with normal states are allowed. A committed location is more restrictive: in all the states where P2.S1 is active (in our example), the only possible transition is the one that ﬁres the edge outgoing from P2.S1.A state having a committed location active is said to 11 be committed: delay is not allowed and the committed location must be left in the successor state (or one of the committed locations if there are several ones). 3 Overview of the Uppaal Toolkit Uppaal uses a client-server architecture, splitting the tool into a graphical user interface and a model checking engine. The user interface, or client, is implemented in Java and the engine, or server, is compiled for di erent platforms (Linux, Windows, Solaris).7 As the names suggest, these two components may be run on di erent machines as they communicate with each other via TCP/IP. There is also a stand-alone version of the engine that can be used on the command line. 3.1 The Java Client The idea behind the tool is to model a system with timed automata using a graphical editor, simulate it to validate that it behaves as intended, and ﬁnally to verify that it is correct with respect to a set of properties. The graphical interface (GUI) of the Java client reﬂects this idea and is divided into three main parts: the editor, the simulator, and the veriﬁer, accessible via three “tabs”. The Editor A system is deﬁned as a network of timed automata, called processes in the tool, put in parallel. A process is instantiated from a parameterised template. The editor is divided into two parts: a tree pane to access the di erent templates and declarations and a drawing canvas/text editor. Figure 9 shows the editor with the train gate example of section 4. Locations are labelled with names and invariants and edges are labelled with guard conditions (e.g., e==id), synchronisations (e.g., go?), and assignments (e.g., x:=0). The tree on the left hand side gives access to di erent parts of the system description: Global declaration Contains global integer variables, clocks, synchronisation channels, and constants. Templates Train, Gate, and IntQueue are di erent parameterised timed automata. A template may have local declarations of variables, channels, and constants. Process assignments Templates are instantiated into processes. The process assignment section contains declarations for these instances. System deﬁnition The list of processes in the system. The syntax used in the labels and the declarations is described in the help system of the tool. The local and global declarations are shown in Fig. 10. The graphical syntax is directly inspired from the description of timed automata in section 2. 12 Fig. 9. The train automaton of the train gate example. The select button is activated in the tool-bar. In this mode the user can move locations and edges or edit labels. The other modes are for adding locations, edges, and vertices on edges (called nails). A new location has no name by default. Two text ﬁelds allow the user to deﬁne the template name and its parameters. Useful trick: The middle mouse button is a shortcut for adding new elements, i.e. pressing it on the canvas, a location, or edge adds a new location, edge, or nail, respectively. The Simulator The simulator can be used in three ways: the user can run the system manually and choose which transitions to take, the random mode can be toggled to let the system run on its own, or the user can go through a trace (saved or imported from the veriﬁer) to see how certain states are reachable. Figure 11 shows the simulator. It is divided into four parts: The control part is used to choose and ﬁre enabled transitions, go through a trace, and toggle the random simulation. The variable view shows the values of the integer variables and the clock constraints. Uppaal does not show concrete states with actual values for the clocks. Since there are inﬁnitely many of such states, Uppaal instead shows sets of concrete states known as symbolic states. All concrete states in a symbolic state share the same location vector and the same values for discrete variables. The possible values of the clocks is described by a set of con7 A version for Mac OS X is in preparation. 13 straints. The clock validation in the symbolic state are exactly those that satisfy all constraints. The system view shows all instantiated automata and active locations of the current state. The message sequence chart shows the synchronisations between the di erent processes as well as the active locations at every step. The Veriﬁer The veriﬁer “tab” is shown in Fig. 12. Properties are selectable in the Overview list. The user may model-check one or several properties,8 insert or remove properties, and toggle the view to see the properties or the comments in the list. When a property is selected, it is possible to edit its deﬁnition (e.g., E<> Train1.Cross and Train2.Stop . . . ) or comments to document what the property means informally. The Status panel at the bottom shows the communication with the server. When trace generation is enabled and the model-checker ﬁnds a trace, the user is asked if she wants to import it into the simulator. Satisﬁed properties are marked green and violated ones red. In case either an over approximation or an under approximation has been selected in the options menu, then it may happen that the veriﬁcation is inconclusive with the approximation used. In that case the properties are marked yellow. 8 several properties only if no trace is to be generated. 14 Fig. 11. View of the simulator tab for the train gate example. The interpretation of the constraint system in the variable panel depends on whether a transition in the transition panel is selected or not. If no transition is selected, then the constrain system shows all possible clock valuations that can be reached along the path. If a transition is selected, then only those clock valuations from which the transition can be taken are shown. Keyboard bindings for navigating the simulator without the mouse can be found in the integrated help system. 3.2 The Stand-alone Veriﬁer When running large veriﬁcation tasks, it is often cumbersome to execute these from inside the GUI. For such situations, the stand-alone command line veriﬁer called verifyta is more appropriate. It also makes it easy to run the veriﬁcation on a remote UNIX machine with memory to spare. It accepts command line arguments for all options available in the GUI, see Table 3 in the appendix. 4 Example 1: The Train Gate 4.1 Description The train gate example is distributed with Uppaal. It is a railway control system which controls access to a bridge for several trains. The bridge is a critical shared resource that may be accessed only by one train at a time. The system is deﬁned as a number of trains (assume 4 for this example) and a controller. A train can not be stopped instantly and restarting also takes time. Therefor, there are timing constraints on the trains before entering the bridge. When approaching, 15 a train sends a appr! signal. Thereafter, it has 10 time units to receive a stop signal. This allows it to stop safely before the bridge. After these 10 time units, it takes further 10 time units to reach the bridge if the train is not stopped. If a train is stopped, it resumes its course when the controller sends a go! signal to it after a previous train has left the bridge and sent a leave! signal. Figures 13 and 14 show two situations. 4.2 Modelling in Uppaal The model of the train gate has three templates: Train is the model of a train, shown in Fig. 9. Gate is the model of the gate controller, shown in Fig. 15. IntQueue is the model of the queue of the controller, shown in Fig. 16. It is simpler to separate the queue from the controller, which makes it easier to get the model right. The Template of the Train The template in Fig. 9 has ﬁve locations: Safe, Appr, Stop, Start, and Cross. The initial location is Safe, which corresponds to a train not approaching yet. The location has no invariant, which means that a train may stay in this location an unlimited amount of time. When a train is approaching, it synchronises with the controller. This is done by the channel synchronisation appr! on the transition to Appr. The controller has a corresponding appr?. The clock x is reset and the parameterised variable e is set 16 Approaching. Can be stopped. Cannot be stopped in Crossing to the identity of this train. This variable is used by the queue and the controller to know which train is allowed to continue or which trains must be stopped and later restarted. The location Appr has the invariant x ≤ 20, which has the e ect that the location must be left within 20 time units. The two outgoing transitions are guarded by the constraints x ≤ 10 and x ≥ 10, which corresponds to the two sections before the bridge: can be stopped and can not be stopped. At exactly 10, both transitions are enabled, which allows us to take into account any race conditions if there is one. If the train can be stopped (x ≤ 10) then the transition to the location Stop is taken, otherwise the train goes to location Cross. The transition to Stop is also guarded by the condition e == id and is synchronised with stop?. When the controller decides to stop a train, it decides which one (sets e) and synchronises with stop!. The location Stop has no invariant: a train may be stopped for an unlimited amount of time. It waits for the synchronisation go?. The guard e == id ensures that the right train is restarted. The model is simpliﬁed here compared to the version described in [60], namely the slowdown phase is not modelled explicitly. We can assume that a train may receive a go? synchronisation even when it is not stopped completely, which will give a non-deterministic restarting time. The location Start has the invariant x ≤ 15 and its outgoing transition has the constraint x ≥ 7. This means that a train is restarted and reaches the crossing section between 7 and 15 time units non-deterministically. The location Cross is similar to Start in the sense that it is left between 3 and 5 time units after entering it. 17 (stopping) train1 (stopped) train2  (restarting) train3  Fig. 14. Now train4 has crossed the bridge and sends a leave! signal. The controller can now let train3 cross the bridge with a go! signal. Train2 is now waiting and train1 is stopping. train4:leave! Controller The Template of the Gate The gate controller in Fig. 15 synchronises with the queue and the trains. Some of its locations do not have names. Typically, they are committed locations (marked with a c). The controller starts in the Free location (i.e., the bridge is free), where it tests the queue to see if it is empty or not. If the queue is empty then the controller waits for approaching trains (next location) with the appr? synchronisation. When a train is approaching, it is added to the queue with the add! synchronisation. If the queue is not empty, then the ﬁrst train on the queue (read by hd!) is restarted with the go! synchronisation. In the Occ location, the controller essentially waits for the running train to leave the bridge (leave?). If other trains are approaching (appr?), they are stopped (stop!) and added to the queue (add!). When a train leaves the bridge, the controller removes it from the queue with the rem? synchronisation. The Template of the Queue The queue in Fig. 16 has essentially one location Start where it is waiting for commands from the controller. The Shiftdown location is used to compute a shift of the queue (necessary when the front element is removed). This template uses an array of integers and handles it as a FIFO queue. 4.3 Veriﬁcation We check simple reachability, safety, and liveness properties, and for absence of deadlock. The simple reachability properties check if a given location is reachable: – E<> Gate.Occ: the gate can receive and store messages from approaching trains in the queue. – E<> Train1.Cross: train 1 can cross the bridge. We check similar properties for the other trains. – E<> Train1.Cross and Train2.Stop: train 1 can be crossing the bridge while train 2 is waiting to cross. We check for similar properties for the other trains. – E<> Train1.Cross && Train2.Stop && Train3.Stop && Train4.Stop is similar to the previous property, with all the other trains waiting to cross the bridge. We have similar properties for the other trains. 18 The following safety properties must hold for all reachable states: – A[] Train1.Cross+Train2.Cross+Train3.Cross+Train4.Cross<=1. There is not more than one train crossing the bridge at any time. This expression uses the fact that Train1.Cross evaluates to true or false, i.e., 1 or 0. – A[] Queue.list[N-1] == 0: there can never be N elements in the queue, i.e., the array will never overﬂow. Actually, the model deﬁnes N as the number of trains + 1 to check for this property. It is possible to use a queue length matching the number of trains and check for this property instead: A[] (Gate.add1 or Gate.add2) imply Queue.len < N-1 where the locations add1 and add2 are the only locations in the model from which add! is possible. The liveness properties are of the form Train1.Appr --> Train1.Cross: whenever train 1 approaches the bridge, it will eventually cross, and similarly for the other trains. Finally, to check that the system is deadlock-free, we verify the property A[] not deadlock. Suppose that we made a mistake in the queue, namely we wrote e:=list[1] in the template IntQueue instead of e:=list[0] when reading the head on the transition synchronised with hd?. We could have been confused when thinking in terms of indexes. It is interesting to note that the properties still hold, except 19 list[len]:=e, add? len++notempty! len>0 empty! len==0 rem! len>=1 len--, i := 0 i < len list[i]:=list[i+1], i++ Fig. 16. Queue automaton of the train gate. The template is parameterised with int[0,n] e. the liveness ones. The veriﬁcation gives a counter-example showing what may happen: a train may cross the bridge but the next trains will have to stop. When the queue is shifted the train that starts again is never the ﬁrst one, thus the train at the head of the queue is stuck and can never cross the bridge. 5 Example 2: Fischer’s Protocol 5.1 Description Fischer’s protocol is a well-known mutual exclusion protocol designed for n processes. It is a timed protocol where the concurrent processes check for both a delay and their turn to enter the critical section using a shared variable id. 5.2 Modelling in Uppaal The automaton of the protocol is given in Fig. 17. Starting from the initial location (marked with a double circle), processes go to a request location, req, if id==0, which checks that it is the turn for no process to enter the critical section. Processes stay non-deterministically between 0 and k time units in req, and then go to the wait location and set id to their process ID (pid). There it must wait at least k time units, x>k, k being a constant (2 here), before entering the critical section CS if it is its turn, id==pid. The protocol is based on the fact that after (strict) k time units with id di erent from 0, all the processes that want to enter the critical section are waiting to enter the critical section as well, but only one has the right ID. Upon exiting the critical section, processes reset id to allow other processes to enter CS. When processes are waiting, they may retry when another process exits CS by returning to req. 20 x>k, id==pidcs wait Fig. 17. Template of Fischer’s protocol. The parameter of the template is const pid. The template has the local declarations clock x; const k 2;. 5.3 Veriﬁcation The safety property of the protocol is to check for mutual exclusion of the location CS: A[] P1.cs + P2.cs + P3.cs + P4.cs <= 1. This property uses the trick that these tests evaluate to true or false, i.e., 0 or 1. We check that the system is deadlock-free with the property A[] not deadlock. The liveness properties are of the form P1.req --> P1.wait and similarly for the other processes. They check that whenever a process tries to enter the critical section, it will always eventually enter the waiting location. Intuitively, the reader would also expect the property P1.req --> P1.cs that similarly states that the critical section is eventually reachable. However, this property is violated. The interpretation is that the process is allowed to stay in wait for ever, thus there is a way to avoid the critical section. Now, if we try to ﬁx the model and add the invariant x <= 2*k to the wait location, the property P1.req --> P1.cs still does not hold because it is possible to reach a deadlock state where P1.wait is active, thus there is a path that does not lead to the critical section. The deadlock is as follows: P1.wait with 0 ≤ x ≤ 2 and P4.wait with 2 ≤ x ≤ 4. Delay is forbidden in this state, due to the invariant on P4.wait and P4.wait can not be left because id == 1. 6 Example 3: The Gossiping Girls 6.1 Description Let n girls have each a private secret they wish to share with each other. Every girl can call another girl and after a conversation, both girls know mutually all their secrets. The problem is to ﬁnd out how many calls are necessary so that all the girls know all the secrets. A variant of the problem is to add time to conversations and ask how much time is necessary to exchange all the secrets, allowing concurrent calls. The basic formulation of the problem is not timed and is typically a combinatorial problem with a string of n bits that may take (at most) 2n values for 21 2every girl. That means we have in total a string of n bits taking 2n 2 values (in product with other states of the system). 6.2 Modelling in Uppaal We face choices regarding the representation of the secrets and where to store them. One way is to use one integer and manually set or reset its bits using arithmetic operations. Although the size of the system is limited by the size of the integers, a quick complexity evaluation shows that the state-space explodes too quicly anyway so this is not really a limitation. Another way is to use an array of booleans. The solution with the integer sounds like hacking and in fact it is so specialized that we will have problem to reﬁne the model later. The model with booleans is certainly more readable, which is desirable for formal veriﬁcation. The second choice is where to store the messages: in one big shared table locally with every girl process. The referenced models are available at http://www.cs.aau.dk/~adavid/UPPAAL-tutorial/. Generic Declarations The global declaration contains: const int GIRLS = 4; typedef int[0,GIRLS-1] girl_t; chan phone[girl_t], reply[girl_t]; This allows us to scale the model easily. Notice that it is possible to declare that arrays of channels are indexed by a given type, which implicitely gives them the right size. This is necessary to use symmetry reduction through scalar sets later. The girl process is named Girl and has girl t id as parameter. Every girl has a di erent ID. The system declaration is simply: system Girl;. This makes use of the auto-instantiation feature of Uppaal. All instances of the template Girl ranging over its parameters are generated. The number of instances is controlled by the constant GIRLS. Flexible Modelling We declare three local functions to the template Girl. Notice that they have access to the parameter id. These functions are used to initialize the template (start()) with a unique secret and to send and receive secrets to other templates (talk() and listen()). We can change these functions but still keep the same model, which makes the model ﬂexible. Integers The encoding with integers has meta int tmp; added to the global declarations and the following to the local declaration of the template Girl: girl_t g; int secrets; void start() { secrets = 1 << id; } void talk() { tmp = secrets; } void listen() { secrets |= tmp; } 22 Initialization is done by setting bit id to one. The initial committed location ensures all girls are initialized before they start to exchange secrets. Then we have a standard message passing using a shared variable with the receiver merging the secrets sent with her own (logical or). The shared variable is declared meta, which means it is a special temporary variable not part of the state, i.e., never refer to such a variable between two states. We assume that these functions are used with channel synchronization. Booleans The encoding with booleans has meta bool tmp[girl t]; added to the global declarations and the following to the local declarations of the template Girl: girl_t g; bool secrets[girl_t]; void start() { secrets[id] = true; } void talk() { tmp = secrets; } void listen() { for(i:girl_t) secrets[i] |= tmp[i]; } In this version we use assignment between arrays for talk(). The function listen() uses an iterator. The automaton for models gossip0.xml (with integers) and gossip1.xml (with booleans) is given in Fig. 18. This ﬁrst attempt captures the fact that we want the model to be symmetric with respect to sending and receiving and is quite natural with symmetric uses of talk() and listen(). The local variable g records which other girl is a given template communicating with. The sender selects its receiver and the receiver its sender. start() Ringing j : girl_t j : girl_t id != j phone[j]? phone[j]! listen(), g = j, g = j talk() Reply Listen Fig. 18. First attempt for modelling the gossiping girls. Let us ﬁrst improve the model on three points: 1. The intermediate state Listen should be made committed otherwise all interleaving of half-started and complete calls will occur. 2. One select is enough because we are modelling something else here, namely girl id selects a channel j and any other girl that selects the same channel can communicate with id. 23 3. The local variable g contributes badly to the state-space when its value is not relevant, i.e., the previous communication does not need to be kept. We can set it in a symmetric manner upon the start and reset it after communication to id. These are typical “optimizations” of a model: Avoid useless interleavings by using committed locations, make sure you model exactly what you need and not more, and “active variable reduction”. The updated model (gossip2.xml/integers, gossip3.xml/booleans) is shown in Fig. 19. The template keeps as an invariant that the variable g is always equal to id whenever it is not sending. In addition, when a channel j is selected, then it corresponds to exactly girl j. Only one committed location is enough but it is a good practice to mark them both. It is more explicit when we read the model. Since the model performs better, we can now check with 5 girls instead of 4 within roughly the same time, which is a very good improvement considering the exponential complexity of the model. start(), g = id Ringing reply[id]! Replytalk() Fig. 19. Improved model of the gossiping girls. Optimizing Further We can abstract which communication line is used by declaring only one channel chan call. Since the semantics says that any pair of enabled edges (call!,call?) can be taken, we do not need to make an extra select. In addition, processes cannot synchronize with themselves so we do not need this check either. The downside is that we lose the information on the receiver from the sender point of view. We do not need this in our case. We can get rid of the local variable g as well. We could use the sequence talk()-listen()-talk()-listen() with the old functions but we can simplify these by merging the middle listen()-talk() into one and simplifying listen() to a simple assignment since we know that the message already contains the secrets sent. The global declaration is updated with only chan call; for the channel. The updated automaton is depicted in Fig. 20. The integer version of the model (gossip4.xml) has the following local functions: 24 reply[g]? listen(), g = id start() Ringing Listen int secrets; void start() { secrets = 1 << id; } void talk() { tmp = secrets; } void exchange() { secrets = (tmp |= secrets); } void listen() { secrets = tmp; } The boolean version of the model (gossip5.xml) is changed to: bool secrets[girl_t]; void start() { secrets[id] = true; } void talk() { tmp = secrets; } void exchange() { for(i:girl_t) tmp[i] |= secrets[i]; secrets = tmp; } void listen() { secrets = tmp; } The exchange function could have been written as void exchange() { for(i:girl_t) secrets[i] = (tmp[i] |= secrets[i]); } which is almost the same. The di erence is that the number of interpreted instructions is lower in the ﬁrst case. A step further would be to inline these functions on the edges in the model but then we would lose readability to gain less than 5% in speed. It is possible to further optimize the model by having one parameterized shared table and avoid message passing all-together. We leave this as an exercise for the reader but we notice that this change destroys the nice design with the local secrets to each process. 6.3 Veriﬁcation We check the property that all girls know all secrets. For the integer version of the model, the property is: 25 E<> forall(i:girl_t) forall(j:girl_t) (Girl(i).secrets & (1 << j)) We can write a shorter but less obvious equivalent formula that takes advantage of the fact that 2GIRLS − 1 generates a bit mask with the ﬁrst GIRLS bits set to one: E<> forall(i:girl_t) Girl(i).secrets == ((1 << GIRLS)-1) The formula for the boolean version is: E<> forall(i:girl_t) forall(j:girl_t) Girl(i).secrets[j] The formulas use the “for-all” construct, which gives compact formulas that automatically scale with the number of girls in the model. The version with the integers checks with a bit mask that the bits are set. Table 1 shows the resource consumption for the di erent models with di erent number of girls. Experiments are run on an AMD Opteron 2.2GHz with Uppaal rev. 2842. The results show how important it is to be careful with the model and Girls  4  5  6  gossip0 gossip1 gossip2 gossip3 gossip4 gossip5  0.6s/24M 1.0s/24M 0.1s/1.3M 0.1s/1.3M 0.1s/1.3M 0.1s/1.3M  498s/3071M 809s/3153M 0.3s/22M 0.5s/22M 0.2s/22M 0.3s/22M  --71s/591M 106s/607M 37s/364M 63s/381M  Table 1. Resource consumption for the di erent models with di erent number of girls. Results are in seconds/Mbytes. to optimize the model to reduce the state-space whenever possible. We notice that we do not even have time in this model. The model with integers is faster due to its simplicity but consumes marginally less memory. 6.4 Improved Veriﬁcation Uppaal features two major techniques to improve veriﬁcation. These techniques concern directly veriﬁcation and are orthogonal to model optimization. The ﬁrst is symmetry reduction. Since we designed our model to be symmetric from the start, taking advantage of this feature is done by using a scalar set for the type girl t. The second feature is the generalized sweep-line method. We need to deﬁne a progress measure to help the search. Furthermore, only the model with booleans is eligible for symmetry reduction since we cannot access individual bits in an integers in a symmetric manner (using scalars). Symmetry Reduction The only change required is for the deﬁnition of the type girl t. We use a scalar set for the new model (gossip6.xml): typedef scalar[GIRLS] girl_t; 26 Sweep-line We need to deﬁne a progress measure that is cheap to compute and relevant to help the search. It is important that it is cheap to compute since it will be evaluated for every state. To do so, we add int m; to the global declarations, we add the progress measure deﬁnition after the system declaration: progress { m; } Finally, we compute m in the exchange function as follows: void exchange() { m = 0; for(i:girl_t) { m += tmp[i] ^ secrets[i]; tmp[i] |= secrets[i]; } } This measures counts the number of new messages exchanged per communication. Girls  4  5  6  7  gossip6 gossip7  0.1s/1.3M 0.1s/1.3M  0.1s/1.3M 0.1s/1.3M  3.4s/29M 0.3s/21M  399s/1115M 29s/108M  Table 2. Resource consumption using symmetry reduction (gossip6) combined with the sweep-line method (gossip7). Table 2 show that these features give gains with another order of magnitude both in speed and memory. The model still explodes exponentially but we cannot avoid it given its nature. 7 Modelling Patterns In this section we present a number of useful modelling patterns for Uppaal. A modelling pattern is a form of designing a model with a clearly stated intent, motivation and structure. We observe that most of our Uppaal models use one or more of the following patterns and we propose that these patterns are imitated when designing new models. 7.1 Variable Reduction Intent To reduce the size of the state space by explicitly resetting variables when they are not used, thus speeding up the veriﬁcation. 27 Motivation Although variables are persistent, it is sometimes clear from the way a model behaves, that the value of a variable does not matter in certain states, i.e., it is clear that two states that only di er in the values of such variables are in fact bisimilar. Resetting these variables to a known value will make these two states identical, thus reducing the state space. Structure The pattern is most easily applied to local variables. Basically, a variable v is called inactive in a location l , if along all paths starting from l , v will be reset before it will be used. If a variable v is inactive in location v , one should reset v to the initial value on all incoming edges of l . The exception to this rule is when v is inactive in all source locations of the incoming edges to l . In this case, v has already been reset, and there is no need to reset it again. The pattern is also applicable to shared variables, although it can be harder to recognise the locations in which the variable will be inactive. For clocks, Uppaal automatically performs the analysis described above. This process is called active clock reduction. In some situations this analysis may fail, since Uppaal does not take the values of non-clock variables into account when analysing the activeness. In those situations, it might speed up the veriﬁcation, if the clocks are reset to zero when it becomes inactive. A similar problem arises if you use arrays of clocks and use integer variables to index into those arrays. Then Uppaal will only be able to make a coarse approximation of when clocks in the array will be tested and reset, often causing the complete array to be marked active at all times. Manually resetting the clocks might speed up veriﬁcation. Sample The queue of the train gate example presented earlier in this tutorial uses the active variable pattern twice, see Fig. 21: When an element is removed, all the remaining elements of the list are shifted by one position. At the end of the loop in the Shiftdown location, the counter variable i is reset to 0, since its value is no longer of importance. Also the freed up element list[i] in the list is reset to zero, since its value will never be used again. For this example, the speedup in veriﬁcation gained by using this pattern is approximately a factor of 5. Known Uses The pattern is used in most models of some complexity. 7.2 Synchronous Value Passing Intent To synchronously pass data between processes. Motivation Consider a model of a wireless network, where nodes in the network are modelled 28 list[len]:=e, add? len++notempty! len>0 empty! len==0 rem! len>=1 len--, i := 0 i < len list[i]:=list[i+1], i++ Fig. 21. The model of the queue in the train gate example uses active variable reduction twice. Both cases are on the edge from Shiftdown to Start: The freed element in the queue is reset to the initial value and so is the counter variable i. as processes. Neighbouring nodes must communicate to exchange, e.g., routing information. Assuming that the communication delay is insigniﬁcant, the handshake can be modelled as synchronisation via channels, but any data exchange must be modelled by other means. The general idea is that a sender and a receiver synchronise over shared binary channels and exchange data via shared variables. Since Uppaal evaluates the assignment of the sending synchronisation ﬁrst, the sender can assign a value to the shared variable which the receiver can then access directly. Structure There are four variations of the value passing pattern, see Fig. 22. They di er in whether data is passed one-way or two-way and whether the synchronisation is unconditional or conditional. In one-way value passing a value is transfered from one process to another, whereas two-way value passing transfers a value in each direction. In unconditional value passing, the receiver does not block the communication, whereas conditional value passing allows the receiver to reject the synchronisation based on the data that was passed. In all four cases, the data is passed via the globally declared shared variable var and synchronisation is achieved via the global channels c and d. Each process has local variables in and out. Although communication via channels is always synchronous, we refer to a c! as a send-action and c? as a receive-action. Notice that the variable reduction pattern is used to reset the shared variable when it is no longer needed. Alternatively, the shared variable can be declared meta, in which case the reset is not necessary since the variable is not part of the state. In one-way value passing only a single channel c and a shared variable var is required. The sender writes the data to the shared variable and performs a 29 Unconditio nal  Conditional  One-way c! var := out ‚ ‚ ‚ ‚ ‚  c? in := var, var := 0  c! var := out ‚ ‚ ‚ ‚ ‚  c? in := var, var := 0 cond(in)  Asymmetric two-way c! var := out d? in := var, var :=0 ‚ ‚ ‚ ‚ ‚  c? in := var d! var := out  c! var := out ‚ ‚ ‚ ‚ ‚ cond1(var) d? in := var, var :=0  c? in := var, var := out cond2(in) d!  Fig. 22. The are essentially four combinations of conditional, unconditional, one-way and two-way synchronous value passing. send-action. The receiver performs the co-action, thereby synchronising with the sender. Since the update on the edge with send-action is always evaluated before the update of the edge with the receive-action, the receiver can access the data written by the sender in the same transition. In the conditional case, the receiver can block the synchronisation according to some predicate cond(in) involving the value passed by the sender. The intuitive placement of this predicate is on the guard of the receiving edge. Unfortunately, this will not work as expected, since the guards of the edges are evaluated before the updates are executed, i.e., before the receiver has access to the value. The solution is to place the predicate on the invariant of the target location. Two-way value passing can be modelled with two one-way value passing pattern with intermediate committed locations. The committed locations enforce that the synchronisation is atomic. Notice the use of two channels: Although not strictly necessary in the two-process case, the two channel encoding scales to the case with many processes that non-deterministically choose to synchronise. In the conditional case each process has a predicate involving the value passed by the other process. The predicates are placed on the invariants of the committed locations and therefore assignment to the shared variable in the second process must be moved to the ﬁrst edge. It might be tempting to encoding conditional two-way value passing directly with two one-way conditional value passing pattern, i.e., to place the predicate of the ﬁrst process on the third location. Unfortunately, this will introduce spurious deadlocks into the model. If the above asymmetric encoding of two-way value passing is undesirable, the symmetric encoding in Fig. 23 can be used instead. Basically, a process can nondeterministically choose to act as either the sender or the receiver. Like before, 30 committed locations guarantee atomicity. If the synchronisation is conditional, the predicates are placed on the committed locations to avoid deadlocks. Notice that the symmetric encoding is more expensive: Even though the two paths lead to the same result, two extra successors will be generated. c! c? var := out in := var, var := out cond(var) cond(in) d? d! in := var, var := 0 Fig. 23. In contrast to the two-way encoding shown in Fig 22, this encoding is symmetric in the sense that both automata use the exact same encoding. The symmetry comes at the cost of a slightly larger state space. Sample The train gate example of this tutorial uses synchronous one-way unconditional value passing between the trains and the gate, and between the gate and the queue. In fact, the value passing actually happens between the trains and the queue and the gate only act as a mediator to decouple the trains from the queue. Known Uses Lamport’s Distributed Leader Election Protocol. Nodes in this leader election protocol broadcast topology information to surrounding nodes. The communication is not instantaneous, so an intermediate process is used to model the message. The nodes and the message exchange data via synchronous one-way unconditional value passing. Lynch’s Distributed Clock Synchronisation Protocol. This distributed protocol synchronises drifting clocks of nodes in a network. There is a fair amount of non-determinism on when exactly the clocks are synchronised, since the protocol only required this to happen within some time window. When two nodes synchronise non-deterministically, both need to know the other nodes identity. As an extra constraint, the synchronisation should only happen if it has not happened before in the current cycle. Here the asymmetric two-way conditional value passing pattern is used. The asymmetric pattern suÿces since each node has been split into two processes, one of them being dedicated to synchronising with the neighbours. 31 7.3 Synchronous Value Passing (bis) Intent To synchronously pass integers with a small range between processes. Motivation Similarly to the previous value passing pattern, it is useful to send values between processes. However, this pattern is specialized to integers with small ranges, which gives us the beneﬁt to avoid using a shared variable for the communication. Structure The idea is to use arrays of channels to pass speciﬁc integers. The pattern is given for the general case of passing an integer value between MIN and MAX. Declare the array chan send[MAX-MIN+1] with MAX and MIN being either constants or the actual value of the desired range. Figure 7.3 shows the pattern. As an example the sender is sending the values 2, 3, or a randomly chosen value. The receiver is using the select feature of Uppaal 3.6 to ﬁnd the right value. Notice that this is expensive for the model-checker if the range is large and will degrade performance. Two-way value passing can be modeled similarly to the previous pattern with the shared variable removed. Conditional value passing works for one-way only. send[3-MIN]! send[2-MIN]! send[random-MIN]! ‚‚‚‚‚ i:int[MIN,MAX] send[i-MIN]? value=i random:int[MIN,MAX] sent received (a) Sender. (b) Receiver. Fig. 24. Value passing using an array of channels. 7.4 Multicast Intent To encode multicast to at least N receivers (or similarly exactly N ). Motivation Uppaal provides pair-wise synchronisation via regular channels (chan) and broadcast synchronisation via broadcast channels (broadcast chan). In some models it is useful to ensure there are at least N receivers available and have the multicast behaviour, typically for communication protocols. Structure Use a shared variable (e.g. ready) that is incremented on the edges leading to a 32 location where it is possible to receive and decrement this variable on the edges that leave this location. In addition, add the constraint in the sender process on the required number of receiver (e.g. r eady > = N ). Figure 7.4 illustrates the patter. doSomething ready++ waitN waiting ready >= 3 sentN received multisend? multisend! ‚‚‚‚‚ready-(a) Sender. (b) Receiver. Fig. 25. Multicast from one sender to at least N receivers (3 in this example). 7.5 Atomicity Intent To reduce the size of the state space by reducing interleaving using committed locations, thus speeding up the veriﬁcation. Motivation Uppaal uses an asynchronous execution model, i.e., edges from di erent automata can interleave, and Uppaal will explore all possible interleavings. Partial order reduction is an automatic technique for eliminating unnecessary interleavings, but Uppaal does not support partial order reduction. In many situations, unnecessary interleavings can be identiﬁed and eliminated by making part of the model execute in atomic steps. Structure Committed locations are the key to achieving atomicity. When any of the processes is in a committed location, then time cannot pass and at least one of these processes must take part in the next transition. Notice that this does not rule out interleaving when several processes are in a committed location. On the other hand, if only one process is in a committed location, then that process must take part in the next transition. Therefore, several edges can be executed atomically by marking intermediate locations as committed and avoiding synchronisations with other processes in the part that must be executed atomically, thus guaranteeing that the process is the only one in a committed location. Sample The pattern is used in the Queue process of the train gate example, see Fig. 26. 33 list[len]:=e, add? len++notempty! len>0 empty! len==0 rem! len>=1 len--, i := 0 i < len list[i]:=list[i+1], i++ Fig. 26. When removing the front element from the queue, all other elements must be shifted down. This is done in the loop in the Shiftdown location. To avoid unnecessary interleavings, the location is marked committed. Notice that the edge entering Shiftdown synchronises over the rem channel. It is important that target locations of edges synchronising over rem in other processes are not marked committed. Known Uses Encoding of control structure A very common use is when encoding control structures (like the encoding of a for-loop used in the IntQueue process of the train-gate example): In these cases the interleaving semantics is often undesirable. Multi-casting Another common use is for complex synchronisation patterns. The standard synchronisation mechanism in Uppaal only supports binary or broadcast synchronisation, but by using committed locations it is possible to atomically synchronise with several processes. One example of this is in the train-gate example: Here the Gate process acts as a mediator between the trains and the queue, ﬁrst synchronising with one and then the other – using an intermediate committed location to ensure atomicity. 7.6 Urgent Edges Intent To guarantee that an edge is taken without delay as soon as it becomes enabled. Motivation Uppaal provides urgent locations as a means of saying that a location must be left without delay. Uppaal provides urgent channels as a means of saying that a synchronisation must be executed as soon as the guards of the edges involved are enabled. There is no way of directly expressing that an edge without synchronisation should be taken without delay. This pattern provides a way of encoding this behaviour. 34 Structure The encoding of urgent edges introduces an extra process with a single location and a self loop (see Fig. 27 left). The self loop synchronises on the urgent channel go. An edge can now be made urgent by performing the complimentary action (see Fig. 27 right). The edge can have discrete guards and arbitrary updates, but no guards over clocks. go!‚‚‚‚‚ go? Fig. 27. Encoding of urgent edges. The go channel is declared urgent. Sample This pattern is used in a model of a box sorting plant (see http://www.cs.auc. dk/∼behrmann/esv03/exercises/index.html#sorter): Boxes are moved on a belt, registered at a sensor station and then sorted by a sorting station (a piston that can kick some of the boxes of the belt). Since it takes some time to move the boxes from the sensor station to the sorting station, a timer process is used to delay the sorting action. Figure 28 shows the timer (this is obviously not the only encoding of a timer – this particular encoding happens to match the one used in the control program of the plant). The timer is activated by setting a shared variable active to true. The timer should then move urgently from the passive location to the wait location. This is achieved by synchronising over the urgent channel go. x==ctime eject! active:=false x<=ctime active==true go? Fig. 28. Sample of a timer using an urgent edge during activation. 35 7.7 Timers Intent To emulate a timer where, in principle, time decreases until it reaches zero, at which point the timer is said to time-out. Motivation Although clocks are powerful enough to model timing mechanisms, some systems are more naturally modelled using timers, in particular event based models. In such models, a timer is started, may be restarted, and counts down until a time-out event is generated. Structure The pattern gives an equivalent of a timer object mapped on a process in Uppaal. We deﬁne the following operations for a timer object t: – void set(TO): this function starts or restarts the timer with a time-out value of TO. The timer will count down for TO time units. TO is an integer. – bool expired(): this function returns true if the timer has expired, false otherwise. When the timer has not been started yet, it is said to have expired. This function may be called at any time to test the timer. We map the above deﬁned timer as a process in Uppaal. When a timer t is to be used in the model, its functions are mapped as follows: – t.set(v) where v is an integer variable is mapped to the synchronisation set! and the assignment value := v, where the channel set and the integer value are the parameters of the timer template. – t.expired() is mapped to the guard value == 0, where value is a parameter of the timer template. As a variant of this basic timer model, it is possible to generate a time-out synchronisation, urgent or not depending on the needs, by using the pattern to encode urgent edges shown in Fig. 27. If the time-out value is a constant, we can optimise the coding to: – t.set() (no argument since the time-out is a constant) is mapped to set!. – t.expired() is mapped to active == false where active is a parameter of the template. The templates are shown in Fig. 29. The two states correspond to the timer having expired (timer inactive) and waiting to time-out (timer active). The template (a) makes use of a feature of Uppaal to mix integers and clocks in clock constraints. The constraint is dynamic and depends on the value of the integer. When returning to the state Expired, the timer resets its value, which has the e ect to (1) use variable reduction (see pattern 7.1) and (2) to provide a simple way to test for a time-out. The template (b) is simpler in the sense that a constant is used in the clock constraints. Testing for the time-out is equivalent to test on the boolean variable active. 36 set? set? x:=0 Waiting x:=0, active:=true Waiting Expired x<=value Expired x<=TO set? set? x:=0 x:=0 x==value x==TO value:=0 active:=false (a) Timer with variable time-out. (b) Timer with constant time-out. Fig. 29. Template of the timer pattern. Template (a) has int value; chan set as parameters and template (b) has bool active; chan set; const TO as parameters. Both templates have the local declaration clock x. Known Uses A variation of the timer pattern is used in the box sorting machine of the previous pattern (for educational purposes reconstructed in Lego): A timer is activated when a coloured brick passes a light sensor. When the timer times out a piston kicks the brick from the transport belt. 7.8 Bounded Liveness Checking Intent To check bounded liveness properties, i.e., properties that are guaranteed not only to hold eventually but within some speciﬁed upper time-bound. Time-bounded liveness properties are essentially safety properties and hence often computationally easier to verify. Thus moving from (unconditional) liveness properties to a time-bounded versions will not only provide additional information — i.e., if one can provide a valid bound — but will also lead to more eÿcient veriﬁcation. Motivation For real-time systems general liveness properties are often not suÿciently expressive to ensure correctness: the fact that a particular property is guaranteed to hold eventually is inadequate in case hard real-time deadlines must be observed. What is really needed is to establish that the property in question will hold within a certain upper time-limit. Structure We consider two variations of the pattern for a time-bounded leads-to operator ϕ ;≤t ψ expressing that whenever the state property ϕ holds then the state property ψ must hold within at most t time-units thereafter. In the ﬁrst version of the pattern we use a simple reduction for unbounded leads-to. First the model under investigation is extended with an additional clock z which is reset whenever ϕ starts to hold. The time-bounded leads-to property ϕ ;≤t ψ is now simply obtained by verifying ϕ ; (ψ ∧ z ≤ t). In the second — and more eÿcient version — of the pattern we use the method proposed in [54] in which time-bounded leads-to properties are reduced 37 to simple safety properties. First the model under investigation is extended with a boolean variable b and an additional clock z . The boolean variable b must be initialised to false. Whenever ϕ starts to hold b is set to true and the clock z is reset. When ψ commences to hold b is set to false. Thus the truth-value of b indicates whether there is an obligation of ψ to hold in the future and z measures the accumulated time since this unfulﬁlled obligation started. The time-bounded leads-to property ϕ ;≤t ψ is simply obtained by verifying the safety property A2(b =⇒ z ≤ t). A third method not reported is based on augmenting the model under investigation with a so-called test-automata, see [2,1]. We have deliberately been somewhat vague about the exact nature of the required augmentation of the model. The most simple case is when the (state) ′properties ϕ and ψ are simple locations l and l of component automata. In this simple case the settings of z and b are to be added as assignments of the edges ′entering l and l . Sample In the train gate example presented earlier in this tutorial a natural requirement is that a train is granted access to the crossing within a certain upper time-bound (say 100) after having signalled that it is approaching. In fact, not only is the gate responsible for avoiding collisions on the crossing but also for ensuring a fair and timely handling of requests. In Fig. 30 the Train template has been augmented with a local boolean b and a local clock z. b (to be initialised to 0) is set to 1 on the transition to location Appr and set to 0 on the two transitions to Cross. The clock z is reset on the transition to Appr. On the augmented model we now check the safety property A[](Train1.b==1 imply Train1.z<=100) which establishes that the bounded liveness property holds for Train1. In fact — due to obvious symmetries in the model — it suÿces to establish the property for one train, Train1 say. In this case it would have been advantageous for Train1 to be singleton template in order to avoid augmenting all trains. In particular, the state-space will be substantially smaller in this way. Known Uses Almost any real-time system will have a number of liveness properties where information as to the time-bounds is vital for the correctness of the systems. The Gearbox Controller of [54] o ers an excellent example where a long list of time-bounded liveness properties are directly obtained from requirements speciﬁed by the company Mecel AB. 7.9 Abstraction and Simulation Intent The goal of abstraction is to replace the problem of verifying a very large, infeasible concrete system with a smaller, and hopefully feasible abstract system. In particular, the method could be applied in a compositional manner to subsystems, i.e., various concrete subsystems are replaced by suitable abstractions, 38 e:=id, x:=0 x>=3Safe Cross x<=5 appr! x:=0, b:=0e:=id, x:=0, z:=0, x>=7 b:=1 Appr Start x<=20 x<= 15 x<=10, x:=0e==id go?stop? e==id x:=0 Stop Fig. 30. The Train-Gate augmented to enable time-bounded liveness checking. and the veriﬁcation e ort is conducted on the composition of these abstract subsystems. Motivation Despite enormous improvement in the veriﬁcation capabilities of Uppaal over the past years — and undoubtedly also for the years to come — state-space explosion is an ever existing problem that will be solved by algorithmic advances.9 However, in verifying speciﬁc properties of a systems it is often only part of the behaviour of the various components which is relevant. Often the designer will have a good intuition about what these relevant parts are, in which case (s)he is able to provide abstractions for the various components, which are still concrete enough that the given property holds, yet are abstract (and small) enough that the veriﬁcation e ort becomes feasible. To give a sound methodology two requirements should be satisﬁed. Firstly, the notion of abstraction applied should preserve the properties of interest, i.e., once a property has been shown to hold for the abstraction it should be guaranteed to also hold for the concrete system. Secondly, the abstraction relation should be preserved under composition of systems. In [46,45] we have put forward the notion of (ready) timed simulation preserving safety properties while being a pre-congruence w.r.t. composition. Moreover, for (suggested) abstractions being deterministic and with no internal transitions, timed simulation may be established using simple reachability checking (and hence by using Uppaal). Structure Let A be a timed automaton suggested as an abstraction for some (sub)system 9 unless we succeed in showing P=PSPACE 39 S (possibly a network of timed automata). We assume that A is deterministic (i.e., no location with outgoing edges having overlapping guards) and without any internal transitions. For simplicity we shall assume all channels to be non-urgent and no shared variables exist between S and the remaining system. The extension of the technique to allow for urgency and shared variables can be found in [46]. To show that A is indeed an abstraction of S in the sense that A (ready) timed simulates S a test-automata TA is constructed in the following manner: TA has A as a skeleton but with the direction of actions (input/output) reversed. A distinguished new location bad is added and from all locations l and all actions a an a -labelled edge from l to bad is inserted with guard ¬(g1 ∨ ... ∨ gn) where g1 ... gn is the full set of guards of a -labelled edges out of l in the skeleton. Now S is (ready) timed simulated by A — and hence A is a valid abstraction of S — precisely if the location bad is unreachable in the composite system S TA. Essentially, TA observes that all behaviour of S is matchable by A. Sample Consider the Uppaal model in Fig. 31 consisting of a Sender a Receiver and four pipelining processes Pi. Each pipeline process Pi has the obligation of reacting to a stimulus from its predecessor on channel ai and pass it on to its successor on channel ai+1. A local clock is used to model that each pipeline process adds a minimum delay of 2. After having completed the passing on, the pipeline process engages in some internal computation (the small cycle S2, S3, S4). Now assume that we want to verify that the Receiver will have received its stimulus no sooner than after 8 time-units, or in general 2n in a system with n pipeline processes. Obviously, the system we are looking at is subject to an enormous state-space explosion when we increase the number of pipeline elements. However, for establishing the property in question we need only little information about the various subsystems. For P1P2 we essentially only need to know that the time from reacting to the initial stimulus from the Sender to passing this stimulus on to P3 is at least 4. We do not need to worry about the internal computation nor the precise moment in time when the stimulus was passed from P1 to P2. In particular we should be able to replace P1P2 with the much simpler automaton P1P2. To show that this is a valid substitution we simply show that the BAD location is unreachable for the system P1P2TestP1P2, where TestP1P2 is the test automaton for P1P2. A similar abstraction P3P4 may obviously be given for the subsystem P3P4 and the desired property may now be established for the “much” simpler system P1P2P3P4, rather than the original system. Known Uses The described technique can be found in full details in the Ph.D. thesis of Jensen [45]. In [46] the technique has been successfully applied to the veriﬁcation of a protocol for controlling the switching between power on/o states in audio/video components described in [48]. 40 Sender P1 P2 P3 P4 Receiver S0 S0S0 S0 x>=2 x>=2 x>=2 x>=2 S1 S1 S4 S4 S4 S4S3 S3 S3 S3 a1? a2? a3? a4? S0 S0x:=0 x:=0 x:=0 x:=0S1 S1 S1 S1 ‚‚‚‚‚ ‚‚‚‚‚ ‚‚‚‚‚ ‚‚‚‚‚ ‚‚‚‚‚ a1! a5? a2! a3! a4! a5!S2 S2 S2 S2 S0 Fig. 32. A suggested abstraction and its test automaton. 8 Conclusion Uppaal is a research tool available for free at http://www.uppaal.com/ that features an intuitive graphical interface. It has been ported to di erent platforms and it is in constant development. There are di erent development branches and tools that make use of Uppaal: Cost–UPPAAL supports cost annotations of the model and can do minimal cost reachability analysis [51]. This version also has features for guiding the search. This version can be downloaded from http://www.cs.auc.dk/ ∼behrmann/ guiding/. Distributed–UPPAAL runs on multi-processors and clusters using the combined memory and CPU capacity of the system [17,9]. T–UPPAAL test case generator for black-box conformance testing, see http: //www.cs.auc.dk/∼marius/tuppaal/. Times is a tool set for modelling, schedulability analysis, and synthesis of (optimal) schedules and executable code. The veriﬁcation uses Uppaal [6]. On-going work on the model-checker includes support for hierarchical timed automata, symmetry reduction, U-Code (Uppaal code, large subset of C), im41 proved memory management, etc. The tool has been successfully applied to case studies ranging from communication protocols to multimedia applications: Bang & Olufsen audio/video protocol. An error trace with more than 2000 transition steps was found [35]. TDMA Protocol Start-Up Mechanism was veriﬁed in [55]. Bounded retransmission protocol over a lossy channels was veriﬁed in [24]. Lip synchronisation algorithm was veriﬁed in [23]. Power-down controller in an audio/video component was designed and veriﬁed in collaboration with Bang & Olufsen in [34]. Guided synthesis of control programs for a steel production plant was done in [43]. The ﬁnal control programs were compiled to run on a Lego model of the real plant. Gearbox controller was formally designed and analysed in [54]. Lego Mindstorm programs written in “Not Quite C” have been veriﬁed in [44]. Field bus protocol was modelled and analysed in [30]. Bi-phase Mark Protocol was modelled and analysed in [59] with Uppaal and PVS. Controller for a wafer scanner was designed with the aid of Uppaal in [37]. Car supervision system was formally modelled and analysed in [33]. IEEE1394a root contention protocol was modelled and veriﬁed in [58]. Uppaal is also used in a number of courses on real-time systems and formal veriﬁcation: – http://user.it.uu.se/∼paupet/#teaching Real-time and formal method courses at Uppsala University. – http://csd.informatik.uni-oldenburg.de/teaching/fp realzeitsys ws0001/ result/eindex.html Practical course “Real-Time Systems” at the University of Oldenburg. – http://fmt.cs.utwente.nl/courses/systemvalidation/ System Validation (using Model Checking) at the University of Twente. – http://www.cs.auc.dk/∼behrmann/esv03/ Embedded Systems Validation at Aalborg University. – http://www.cs.auc.dk/∼kgl/TOV04/Plan.html Test and Veriﬁcation at Aalborg University. – http://www.seas.upenn.edu/∼pappasg/EE601/F03/ Hybrid Systems at the University of Pennsylvania. – http://www.it.uu.se/edu/course/homepage/proalgebra Process Algebra at Uppsala University. – http://www.cs.auc.dk/∼luca/SV/ Semantics and Veriﬁcation. – http://www.cs.depaul.edu/programs/courses.asp?subject=SE&courseid=533 Software Validation and Veriﬁcation at DePaul University. – http://www.cs.bham.ac.uk/∼mzk/courses/SafetyCrit/ Safety Critical Systems and Software Reliability at the University of Birmingham. 42 – http://fmt.cs.utwente.nl/courses/sysontomg/ Systeem-ontwikkelomgevingen at the University of Twente. – http://www.niii.ru.nl/F.Vaandrager/PV/ Protocol Validation at the Radboud University of Nijmegen. Finally the following books have parts devoted to Uppaal: – Concepts, Algorithms and Tools for Model-Checking [47]: Lecture notes in its current form. It treats both Spin and Uppaal. – Systems and Software Veriﬁcation: Model-checking Techniques and Tools [22]: This book identiﬁes 6 important tools and has a chapter on Uppaal. References 1. Luca Aceto, Patricia Bouyer, Augusto Burgue˜no, and Kim Guldstrand Larsen. The power of reachability testing for timed automata. Theoretical Computer Science, 1–3(300):411–475, 2003. 2. Luca Aceto, Augusto Burgue˜no, and Kim G. Larsen. Model checking via reachability testing for timed automata. In Bernhard Ste en, editor, Tools and Algorithms for Construction and Analysis of Systems, 4th International Conference, TACAS ’98, volume 1384 of Lecture Notes in Computer Science, pages 263–280. Springer– Verlag, April 1998. 3. Rajeev Alur, Costas Courcoubetis, and David L. Dill. Model-checking for real-time systems. In 5th Symposium on Logic in Computer Science (LICS’90), pages 414–425, 1990. 4. Rajeev Alur and David L. Dill. Automata for modeling real-time systems. In Proc. of Int. Colloquium on Algorithms, Languages, and Programming, volume 443 of LNCS, pages 322–335, 1990. 5. Tobias Amnell, Gerd Behrmann, Johan Bengtsson, Pedro R. D’Argenio, Alexandre David, Ansgar Fehnker, Thomas Hune, Bertrand Jeannet, Kim G. Larsen, M. Oliver M¨oller, Paul Pettersson, Carsten Weise, and Wang Yi. Uppaal -Now, Next, and Future. In F. Cassez, C. Jard, B. Rozoy, and M. Ryan, editors, Modelling and Veriﬁcation of Parallel Processes, number 2067 in Lecture Notes in Computer Science Tutorial, pages 100–125. Springer–Verlag, 2001. 6. Tobias Amnell, Elena Fersman, Leonid Mokrushin, Paul Pettersson, and Wang Yi. Times – a tool for modelling and implementation of embedded systems. In TACAS 2002, volume 2280 of Lecture Notes in Computer Science, pages 460–464. Springer–Verlag, April 2002. 7. Felice Balarin. Approximate reachability analysis of timed automata. In 17th IEEE Real-Time Systems Symposium. IEEE Computer Society Press, 1996. 8. Gerd Behrmann. Data Structures and Algorithms for the Analysis of Real Time Systems. PhD thesis, Aalborg University, 2003. 9. Gerd Behrmann. Distributed reachability analysis in timed automata. Software Tool For Technology Transfer (STTT), 2004. Currently available in the Online First edition of STTT. 10. Gerd Behrmann, Johan Bengtsson, Alexandre David, Kim G. Larsen, Paul Petters-son, and Wang Yi. Uppaal implementation secrets. In Proc. of 7th International Symposium on Formal Techniques in Real-Time and Fault Tolerant Systems, 2002. 11. Gerd Behrmann, Patricia Bouyer, Kim G. Larsen, and Radek Pel¡E1¿nek. Lower and upper bounds in zone-based abstractions of timed automata. International Journal on Software Tools for Technology Transfer, September 2005. 12. Gerd Behrmann, Alexandre David, Kim G. Larsen, John H°akansson, Paul Pettersson, Wang Yi, and Martijn Hendriks. UPPAAL 4.0. In Proceedings of the 3rd International Conference on the Quantitative Evaluation of SysTems (QEST) 2006, IEEE Computer Society, pages 125–126, 2006. 13. Gerd Behrmann, Alexandre David, Kim G. Larsen, M. Oliver M¨oller, Paul Petters-son, and Wang Yi. Uppaal -present and future. In Proc. of 40th IEEE Conference on Decision and Control. IEEE Computer Society Press, 2001. 14. Gerd Behrmann, Alexandre David, Kim G. Larsen, and Wang Yi. Uniﬁcation & sharing in timed automata veriﬁcation. In SPIN Workshop 03, volume 2648 of LNCS, pages 225–229, 2003. 15. Gerd Behrmann, Ansgar Fehnker, Thomas Hune, Kim G. Larsen, Paul Petters-son, and Judi Romijn. Eÿcient guiding towards cost-optimality in uppaal. In T. Margaria and W. Yi, editors, Proceedings of the 7th International Conference on Tools and Algorithms for the Construction and Analysis of Systems, number 2031 in Lecture Notes in Computer Science, pages 174–188. Springer–Verlag, 2001. 16. Gerd Behrmann, Ansgar Fehnker, Thomas Hune, Kim G. Larsen, Paul Pettersson, Judi Romijn, and Frits Vaandrager. Minimum-cost reachability for priced timed automata. In Maria Domenica Di Benedetto and Alberto Sangiovanni-Vincentelli, editors, Proceedings of the 4th International Workshop on Hybrid Systems: Computation and Control, number 2034 in Lecture Notes in Computer Sciences, pages 147–161. Springer–Verlag, 2001. 17. Gerd Behrmann, Thomas Hune, and Frits Vaandrager. Distributed timed model checking -How the search order matters. In Proc. of 12th International Conference on Computer Aided Veriﬁcation, Lecture Notes in Computer Science, Chicago, Juli 2000. Springer–Verlag. 18. Gerd Behrmann, Kim G. Larsen, Justin Pearson, Carsten Weise, and Wang Yi. Eÿcient timed reachability analysis using clock di erence diagrams. In Proceedings of the 12th Int. Conf. on Computer Aided Veriﬁcation, volume 1633 of Lecture Notes in Computer Science. Springer–Verlag, 1999. 19. Johan Bengtsson. Clocks, DBMs and States in Timed Systems. PhD thesis, Uppsala University, 2002. 20. Johan Bengtsson, Bengt Jonsson, Johan Lilius, and Wang Yi. Partial order reductions for timed systems. In Proceedings of the 9th International Conference on Concurrency Theory, September 1998. 21. Johan Bengtsson, Kim G. Larsen, Fredrik Larsson, Paul Pettersson, Yi Wang, and Carsten Weise. New generation of uppaal. In Int. Workshop on Software Tools for Technology Transfer, June 1998. 22. Beatrice Berard, Michel Bidoit, Alain Finkel, Francois Laroussinie, Antoine Petit, Laure Petrucci, Philippe Schnoebelen, and Pierre McKenzie. Systems and Software Veriﬁcation: Model-Checking Techniques and Tools. Springer–Verlag, 2001. 23. Howard Bowman, Giorgio P. Faconti, Joost-Pieter Katoen, Diego Latella, and Mieke Massink. Automatic veriﬁcation of a lip synchronisation algorithm using uppaal. In Bas Luttik Jan Friso Groote and Jos van Wamel, editors, In Proceedings of the 3rd International Workshop on Formal Methods for Industrial Critical Systems. Amsterdam , The Netherlands, 1998. 24. Pedro .R. D’Argenio, Joost-Pieter. Katoen, Theo C. Ruys, and Jan Tretmans. The bounded retransmission protocol must be on time! In In Proceedings of the 43 44 3rd International Workshop on Tools and Algorithms for the Construction and Analysis of Systems, volume 1217 of LNCS, pages 416–431. Springer–Verlag, April 1997. 25. Alexandre David. Hierarchical Modeling and Analysis of Timed Systems. PhD thesis, Uppsala University, November 2003. 26. Alexandre David, Gerd Behrmann, Kim G. Larsen, and Wang Yi. New uppaal architecture. In Paul Pettersson and Wang Yi, editors, Workshop on Real-Time Tools, Uppsala University Technical Report Series, 2002. 27. Alexandre David, Gerd Behrmann, Kim G. Larsen, and Wang Yi. A tool architecture for the next generation of uppaal. In 10th Anniversary Colloquium. Formal Methods at the Cross Roads: From Panacea to Foundational Support, LNCS, 2003. 28. Alexandre David, John H°akansson, Kim G. Larsen, and Paul Pettersson. Model checking timed automata with priorities using dbm subtraction. In Proceedings of the 4th International Conference on Formal Modelling and Analysis of Timed Systems (FORMATS’06), volume 4202 of LNCS, pages 128–142, 2006. 29. Alexandre David, M. Oliver M¨oller, and Wang Yi. Formal veriﬁcation of UML statecharts with real-time extensions. In Ralf-Detlef Kutsche and Herbert Weber, editors, Fundamental Approaches to Software Engineering, 5th International Conference, FASE 2002, volume 2306 of LNCS, pages 218–232. Springer–Verlag, 2002. 30. Alexandre David and Wang Yi. Modelling and analysis of a commercial ﬁeld bus protocol. In Proceedings of the 12th Euromicro Conference on Real Time Systems, pages 165–172. IEEE Computer Society, 2000. 31. Ansgar Fehnker. Citius, Vilius, Melius: Guiding and Cost-Optimality in Model Checking of Timed and Hybrid Systems. PhD thesis, University of Nijmegen, April 2002. 32. Elena Fersman. A Generic Approach to Schedulability Analysis of Real-Time Systems. PhD thesis, Uppsala University, November 2003. 33. B. Gebremichael, T. Krilavicius, and Y.S. Usenko. A formal analysis of a car periphery supervision system. Technical Report NIII-R0418, Radboud University of Nijmegen, 2004. 34. Klaus Havelund, Kim G. Larsen, and Arne Skou. Formal veriﬁcation of a power controller using the real-time model checker uppaal. 5th International AMAST Workshop on Real-Time and Probabilistic Systems, available at http://www.uppaal.co m, 1999. 35. Klaus Havelund, Arne Skou, Kim G. Larsen, and Kristian Lund. Formal modelling and analysis of an audio/video protocol: An industrial case study using uppaal. In Proceedings of the 18th IEEE Real-Time Systems Symposium, pages 2–13, December 1997. 36. M. Hendriks, G. Behrmann, K.G. Larsen, P. Niebert, and F.W. Vaandrager. Adding symmetry reduction to uppaal. In Proceedings First International Workshop on Formal Modeling and Analysis of Timed Systems (FORMATS 2003), volume 2791 of Lecture Notes in Computer Science, 2003. 37. M. Hendriks, N.J.M. van den Nieuwelaar, and F.W. Vaandrager. Model checker aided design of a controller for a wafer scanner. Technical Report NIII-R0430, Radboud University of Nijmegen, 2004. 38. Martijn Hendriks and Kim G. Larsen. Exact acceleration of real-time model checking. In E. Asarin, O. Maler, and S. Yovine, editors, Electronic Notes in Theoretical Computer Science, volume 65. Elsevier Science Publishers, April 2002. 39. Thomas A. Henzinger. Symbolic model checking for real-time systems. Information and Computation, 111:193–244, 1994. 40. Gerard J. Holzmann. Design and Validation of Computer Protocols. Prentice-Hall, 1991. 41. Gerard J. Holzmann. An analysis of bitstate hashing. Formal Methods in System Design, 13:289–307, 1998. 42. John E. Hopcroft and Je rey D. Ullman. Introduction of Automata Theory, Languages, and Computation. Addison Wesley, 2001. 43. Thomas Hune, Kim G. Larsen, and Paul Pettersson. Guided synthesis of control programs using uppaal. In Ten H. Lai, editor, Proc. of the IEEE ICDCS International Workshop on Distributed Systems Veriﬁcation and Validation, pages E15–E22. IEEE Computer Society Press, April 2000. 44. Torsten K. Iversen, K°are J. Kristo ersen, Kim G. Larsen, Morten Laursen, Rune G. Madsen, Ste en K. Mortensen, Paul Pettersson, and Chris B. Thomasen. Model-checking real-time control programs — Verifying LEGO mindstorms systems using uppaal. In Proc. of 12th Euromicro Conference on Real-Time Systems, pages 147– 155. IEEE Computer Society Press, June 2000. 45. Henrik Ejersbo Jensen. Abstraction-Based Veriﬁcation of Distributed Systems. PhD thesis, Aalborg University, June 1999. 46. Henrik Ejersbo Jensen, Kim Guldstrand Larsen, and Arne Skou. Scaling up uppaal automatic veriﬁcation of real-time systems using compositionality and abstraction. In Mathai Joseph, editor, Formal Techniques in Real-Time and Fault-Tolerant Systems, 6th International Symposium, FTRTFT 2000, volume 1926 of Lecture Notes in Computer Science, pages 19–20. Springer–Verlag, 2000. 47. Joost-Pieter Katoen. Concepts, Algorithms, and Tools for Model Checking. http://www.it-c.dk/people/hra/mcpa/katoen.ps, 1999. 48. Arne Skou Klaus Havelund, Kim Guldstrand Larsen. Formal veriﬁcation of a power controller using the real-time model checker Uppaal. In 5th Int. AMAST Workshop on Real-Time and Probabilistic Systems, volume 1601 of Lecture Notes in Computer Science, pages 277–298. Springer–Verlag, 1999. 49. L.M. Kristensen and T. Mailund. A Generalised Sweep-Line Method for Safety Properties. In Proc. of FME’02, volume 2391 of LNCS, pages 549–567. Springer-Verlag, 2002. 50. K°are J. Kristo ersen. Compositional Veriﬁcation of Concurrent Systems. PhD thesis, Aalborg University, August 1998. http://www.itu.dk/people/kjk/publications.html. 51. Kim G. Larsen, Gerd Behrmann, Ed Brinksma, Ansgar Fehnker, Thomas Hune, Paul Pettersson, and Judi Romijn. As cheap as possible: Eÿcient cost-optimal reachability for priced timed automata. In G. Berry, H. Comon, and A. Finkel, editors, Proceedings of CAV 2001, number 2102 in Lecture Notes in Computer Science, pages 493–505. Springer–Verlag, 2001. 52. Kim G. Larsen, Paul Pettersson, and Wang Yi. Uppaal in a nutshell. Int. Journal on Software Tools for Technology Transfer, 1(1–2):134–152, October 1997. 53. Fredrik Larsson, Kim G. Larsen, Paul Pettersson, and Wang Yi. Eÿcient veriﬁcation of real-time systems: Compact data structures and state-space reduction. In Proc. of the 18th IEEE Real-Time Systems Symposium, pages 14–24. IEEE Computer Society Press, December 1997. 54. Magnus Lindahl, Paul Pettersson, and Wang Yi. Formal design and analysis of a gearbox controller. Springer International Journal of Software Tools for Technology Transfer (STTT), 3(3):353–368, 2001. 55. Henrik L¨onn and Paul Pettersson. Formal veriﬁcation of a TDMA protocol startup mechanism. In Proc. of the Paciﬁc Rim Int. Symp. on Fault-Tolerant Systems, pages 235–242, December 1997. 56. Brian Nielsen. Speciﬁcation and Test of Real-Time Systems. PhD thesis, Aalborg University, 2000. 57. Paul Pettersson. Modelling and Veriﬁcation of Real-time Systems Using Timed Automata: Theory and Practice. PhD thesis, Uppsala University, 1999. 58. D.P.L. Simons and M.I.A. Stoelinga. Mechanical veriﬁcation of the IEEE 1394a root contention protocol using Uppaal2k. Springer International Journal of Software Tools for Technology Transfer, pages 469–485, 2001. 59. F.W. Vaandrager and A.L. de Groot. Analysis of a biphase mark protocol with Uppaal and PVS. Technical Report NIII-R0445, Radboud University of Nijmegen, 2004. 60. Wang Yi, Paul Petterson, and Mats Daniels. Automatic veriﬁcation of real-time communicating systems by constraint-solving. In Seventh International Conference on Formal Description Techniques, pages 223–238, 1994. 45 46 Appendix Expression ! ID | NAT | Expression ’[’ Expression ’]’ | ’(’ Expression ’)’ | Expression ’++’ | ’++’ Expression | Expression ’--’ | ’--’ Expression | Expression AssignOp Expression | UnaryOp Expression | Expression BinaryOp Expression | Expression ’?’ Expression ’:’ Expression | Expression ’.’ ID UnaryOp ! ’-’ | ’!’ | ’not’ BinaryOp ! ’<’ | ’<=’ | ’==’ | ’!=’ | ’>=’ | ’>’ | ’+’ | ’-’ | ’*’ | ’/’ | ’%’ | ’&’ | ’|’ | ’^’ | ’<<’ | ’>>’ | ’&&’ | ’||’ | ’<?’ | ’>?’ | ’and’ | ’or’ | ’imply’ AssignOp ! ’:=’ | ’+=’ | ’-=’ | ’*=’ | ’/=’ | ’%=’ | ’|=’ | ’&=’ | ’^=’ | ’<<=’ | ’>>=’ Fig. 33. Syntax of expressions in BNF. 47 Table 3. Options of verifyta and the corresponding options in the GUI. Defaults of verifyta are shown in boldface. State Space Representation -C DBM Use DBMs rather than a minimal constrain graph [53] in the state representation used to store reachable states. This increases the memory usage (more so in models with many clocks), but is often faster. -A Over approximation Use convex hull over-approximation [7]. For timed systems, this can drastically increase veriﬁcation speed. For untimed systems, this has no e ect. -Z Under approximation Use bit-state hashing under-approximation. This reduces memory consumption to a more of less ﬁxed amount. The precision of the approximation is controlled by changing the hash table size. Known as super-trace in [40,41]. -T Reuse Speed up veriﬁcation by reusing the generated state-space when possible. For some combinations of properties this option can possibly lead to a larger state-space representation, thus nullifying the speedup. -U When representing states with minimal constraint graphs, this option changes how states are compared. It reduces the memory consumption at the expense of a more time consuming comparison operator. The reduced memory usage might cancel out the overhead. In the GUI, this is always on. -H Change the size of hash tables used during veriﬁcation. Can give a speedup for large systems. State Space Reduction -S0 None Store all reachable states. Uses most memory, but avoids that any state is explored more than once. -S1 Conservative Store all non-committed states. Less memory when committed locations are used, and for most models states are only explored once. -S2 Aggressive Try hard to reduce the number of states stored. Uses much less memory, but might take much more time. Do not combine this option with depth ﬁrst search, as the running time increases drastically. Search Order -b Breadth First Search the state space using a breadth ﬁrst strategy. -d Depth First Search the state space using a depth ﬁrst strategy. Trace Options -t0 Some Trace Generate some diagnostic trace. -t1 Shortest Trace Generate the shortest (in number of steps) trace. -t2 Fastest Trace Generate the fastest (smallest time delay) trace. -f Write traces to XTR trace ﬁles (which can be read by the GUI). -y By default concrete traces (showing both delay and control transitions) are produced. This option produces symbolic traces like those shown in the GUI. 48 Int J Softw Tools Technol Transfer DOI 10.1007/s10009-014-0361-y SMC Uppaal SMC tutorial Alexandre David · Kim G. Larsen · Axel Legay · Marius Mikucionis · Danny Bøgsted Poulsen © Springer-Verlag Berlin Heidelberg 2015 Abstract This tutorial paper surveys the main features of Uppaal SMC, a model checking approach in Uppaal family that allows us to reason on networks of complex real-timed systems with a stochastic semantic. We demonstrate the modeling features of the tool, new veriﬁcation algorithms and ways of applying them to potentially complex case studies. Keywords Uppaal · Timed automata · Model-checking · Statistical model-checking · Stochastic · Hybrid · Dynamical · Probabilistic 1 Introduction Computer systems play a central role in modern societies and their errors can have dramatic consequences. Proving the correctness of computer systems is therefore a highly relevant activity, on which both industry and academics invest a considerable amount of effort. Among such techniques, one ﬁnds (1) testing [14], the traditional approach that detects bugs by exercising the real system with test cases, and (2) formal methods, e.g., model checking [17], that is a more mathematical approach that can guarantee the absence of bugs in the system design. Both approaches have been largely deployed on complex case studies. Originally, formal veriﬁcation was devoted to software and hardware systems by considering their discrete behav-A. David · K. G. Larsen · M. Mikucionis · D. B. Poulsen Department of Computer Science, Aalborg University, Aalborg, Denmark A. Legay (B) INRIA/IRISA Rennes, Rennes, France e-mail: axel.legay@inria.fr iors. However, the past years shown that real-time aspects play central roles in systems, and that this feature should be taken into account in the veriﬁcation process. Developing formal techniques for such systems has thus been the subject of intensive studies. One of the prominent results on the topic was the introduction of model checking techniques for timed automata [1], a natural model to capture real-time systems whose behaviors depends on clocks that can be reset. Among all the tools that have been developed to implement the timed automata theory, one ﬁnds Uppaal, which has now become the leader in the area. Uppaal is a toolbox for veriﬁcation of real-time systems represented by (a network of) timed automata extended with integer variables, structured data types, and channel synchronization. The tool is jointly developed by Uppsala University and Aalborg University. It has been applied successfully in case studies ranging from communication protocols to multimedia applications (see [4] and [5] for concrete examples). The ﬁrst version of Uppaal was released in 1995 [37]. Since then it has been in constant development. In the same spirit as any other professional model checker such as SPIN, Uppaal proposes efﬁcient data structures [36], a distributed version of Uppaal [10,13], guided and minimal cost reachability [11,12,35], work on UML Statecharts [25], acceleration techniques [29], and new data structures and memory reductions [9,15]. Unfortunately, timed automata is not a panacea. In fact, albeit powerful, the model is not expressive enough to capture behaviors of complex cyber-physical systems. Indeed, the continuous time behaviors of those systems often rely on rich and complex dynamics as well as on stochastic behaviors. The model checking problem for such systems is undecidable, and approximating those behaviors with timed automata [28] was originally the best one could originally do in Uppaal. 123 A. David et al. In this paper, we introduce Uppaal SMC that proposes an alternative to the above-mentioned problem. This new branch of Uppaal proposes to represent systems via networks of automata whose behaviors may depend on both stochastic and non-linear dynamical features. Concretely, in Uppaal SMC, each component of the system is described with an automaton whose clocks can evolve with various rates. Such rates can be speciﬁed with, e.g., ordinary differential equations. To allow for the efﬁcient analysis of probabilistic performance properties, Uppaal SMC proposes to work with statistical model checking (SMC) [38,41], an approach that has been proposed as an alternative to avoid an exhaustive exploration of the state-space of the model. The core idea of SMC is to monitor some simulations of the system, and then use results from the statistics area (including sequential hypothesis testing or Monte Carlo simulation) to decide whether the system satisﬁes the property with some degree of conﬁdence. By nature, SMC is a compromise between testing and classical model checking techniques. Simulation-based methods are known to be far less memory and time intensive than exhaustive ones, more expressive and are oftentimes the only option. SMC has been implemented in a series of tools that have been applied to a wide range of case studies. Unlike more “academic” exhaustive techniques, SMC gets widely accepted in various research areas such as systems biology [16,20,32–34], energy-centric systems [21], automotive/avionics, or software engineering, in particular for industrial applications. There are several reasons for this success. First, it is very simple to implement, understand and use (especially by industry, software engineers, and generally all people that are not pure researchers but customers of our results and tools) [3,4,8]. Second, it does not require extra modeling or speciﬁcation effort, but simply an operational model of the system that can be simulated and checked against state-based properties. Third, it allows to model check properties that cannot be expressed in classical temporal logics. Aside from this, the ﬂexibility of SMC allows it to be used in other areas than veriﬁcation, including planning and robotics. In this paper, SMC is presented as a technique for fully stochastic models thus it validates performance properties of a given deterministic (or stochastic) controller in a given stochastic environment. However, we note that SMC is applicable to systems exhibiting non-determinism (transitions with undeﬁned probability distributions): for instance the SMC tool Cosmos has been used to ﬁnd optimal schedulers for Markov decision processes [26] and in a more recent work [22] an experimental version of Uppaal SMC was used for synthesizing controllers for priced timed Markov decision processes. This paper is a complete tutorial on Uppaal SMC for hybrid and fully stochastic systems. We illustrate most of the modeling features of the tool, the usage of the graphical interface and of the simulation framework. We discuss the SMC algorithms that are available, and introduce some techniques to deal with dynamical systems. Finally, we present some modeling features and tricks. 2 Modeling formalism The modeling formalism of Uppaal SMC is based on a stochastic interpretation and extension of the timed automata (TA) formalism [1] used in the classical model checking version of Uppaal [4]. For individual TA components the stochastic interpretation replaces the non-deterministic choices between multiple enabled transitions by probabilistic choices (that may or may not be user-deﬁned). Similarly, the nondeterministic choices of time delays are reﬁned by probability distributions, which at the component level are given either uniform distributions in cases with time-bounded delays or exponential distributions (with user-deﬁned rates) in cases of unbounded delays. Consider the three TAs A1, A2 and A3 from Fig. 1. Ignoring (initially) the weight annotations on locations and edges, the END locations in the three automata are easily seen to be reachable within the time intervals [6, 12], [4, 12] and [0, +∞). The stochastic interpretation of the three TAs provides probability distributions over the reachability time. For A1, the delay of the three transitions will all be (automatically) resolved by independent, uniform distributions over [2, 4]. Thus the overall reachability time is given as the sum of three uniform distributions as illustrated in Fig. 2a. For A2, the delay distributions determined by the upper and lower (a) A1. (b) A2. (c) A3. Fig. 1 Three stochastic timed automata 123 Uppaal SMC tutorial (a) (b) (c) Fig. 2 Distributions of reachability time, a A1 arrival to END, b A2 arrival to END, c A3 arrival to END path to the END location are similarly given by sums of uniform distributions. Subsequently, the combination ( 16 to 5)6 of these as illustrated in distribution of the overall delay is obtained by a weighted Fig. 2b. Finally, in A3—in the absence of invariants—delays are chosen according to exponential distributions with user-supplied rates (here 21, 2 and 1). In 4 addition, after the initial delay a discrete probabilistic choice 3(14 versus 4) is made. The resulting distribution of the overall reachability time is given in Fig. 2c. Importantly, the distributions provided by the stochastic semantics are in agreement with the delay intervals determined by the standard semantics of the underlying timed automata. Thus, the distributions for A1 and A2 have ﬁnite support by the intervals [ 6, 12] and [ 4, 12] , respectively. Moreover, as indicated by A3, the notion of stochastic timed automata encompasses both discrete and continuous time Markov chains. In particular, the class of reachability time distributions obtained from the stochastic timed automata (STA) of Uppaal SMC includes that of phase-type distributions. Networks As in Uppaal, a model in Uppaal SMC consists of a network of interacting component STAs. Here, it probability C’==2 A0B0 T0 x<=1 y<=2 C’==4 a? T1 a! b! b? T3 AB T Fig. 3 An NSTA, (A| B| T ) 0.72 0.60 0.48 0.36 Cost Time0.24 0.12 0 0 1.2 2.4 3.6 4.8 6.0 Time/Cost Fig. 4 Cumulative probabilities for time and Cost-bounded reachability of T3 is assumed that these components are input-enabled, deterministic (with a probability measure deﬁned on the sets of successors), and non-Zeno. The component STAs communicate via broadcast channels and shared variables to generate Networks of Stochastic Timed Automata (NSTA). The communication is restricted to broadcast synchronizations to keep a clean semantics of only non-blocked components which are racing against each other with their corresponding local distributions. Figure 3 shows an NSTA with three parallel components A, B, and T as speciﬁed using the Uppaal GUI. One can easily see that the composite system ( A| B| T ) has a transition sequence: 1 a! ((A0, B0, T0), [ x = 0, y = 0, C = 0] ) −→−→ 1 b! ((A1, B0, T1), [ x = 1, y = 1, C = 4] ) −→−→ ((A1, B1, T2), [ x = 2, y = 2, C = 6] ), demonstrating that the ﬁnal location T3 of T is reachable. In fact, location T3 is reachable within cost 0 to 6 and within total time 0 and 2 in (A| B| T ) depending on when (and in which order) A and B choose to perform the output actions a! and b! . Given that the choice of these time delays is governed by probability distributions, a measure on sets of runs of NSTAs is induced, according to which quantitative properties such as “the probability of T3 being reached within a total cost-bound of 4.3” become well deﬁned (Fig. 4). For components, as stated in the previous section, Uppaal SMC applies uniform distributions for bounded delays and exponential distributions where a component STA 123 A. David et al. can remain indeﬁnitely in the same location. In a network of STAs, the components repeatedly race against each other, i.e., they independently and stochastically decide on their own how much to delay before outputting, with the “winner” being the component that chooses the minimum delay. For instance, in the NSTA of Fig. 3, A wins the initial race over B with probability 0.75. As observed in [23], though the stochastic semantic of each individual STA in Uppaal SMC is rather simple (but quite realistic), arbitrarily complex stochastic behavior can be obtained by their composition when mixing individual distributions through message passing. The beauty of our model is that these distributions are naturally and automatically deﬁned by the network of STAs. Train crossing example Uppaal SMC takes as input NSTAs as described above. Additionally, there is support for all other features of the Uppaal model checker’s input language such as integer variables, data structures and user-deﬁned functions, which greatly ease modeling. Uppaal SMC allows the user to specify an arbitrary (integer) rate for the clocks on any location. In addition, the automata support branching edges where weights can be added to give a distribution on discrete transitions. It is important to note that rates and weights may be general expressions that depend on the states and not just simple constants. To illustrate the extended input language, we consider a train-gate example adapted from [42]. The example model is distributed together with Uppaal SMC tool. A number of trains are approaching a bridge on which there is only one track. To avoid collisions, a controller stops the trains. It restarts them when possible to make sure that trains will eventually cross the bridge. There are timing constraints for stopping the trains modeling the fact that it is not possible to stop trains instantly. The interesting point w.r.t. SMC is to deﬁne the arrival rates of these trains. Figure 5ashows the template for a train. The location Safe has no invariant and deﬁnes the rate of the exponential distribution for delays. Trains delay according to this distribution and then approach by synchronizing on appr[i] with the gate controller. Here, we deﬁne the rational 1+id where id is the N 2 identiﬁer of the train and N is the number of trains. Rates are given by expressions that can depend on the current states. Trains with higher id arrive faster. Taking transitions from locations with invariants is given by a uniform distribution over the time interval deﬁned by the invariant. This happens in locations Appr, Cross, and Start, e.g., it takes some time picked uniformly between 3 and 5 time units to cross the bridge. Figure 5b shows the gate controller that keeps track of the trains with an internal queue data structure (not shown here). It uses functions to queue trains (when a train approaches and the bridge is occupied in Occ)or dequeue them (when some train leaves and the bridge is free). (a) (b)  Free  e : id_t  e == front()  leave[e]?  dequeue()   Occ  e : id_t  appr[e]?  stop[tail()]!  enqueue(e)  Stopping Fig. 5 Templates for the train-gate example, a train, b gate controller 3 Query language In addition to the standard model checking queries—i.e., reachability, invariance, inevitability and leads-to, which are still available—Uppaal SMC provides a number of new queries related to the stochastic interpretation of timed automata. Uppaal SMC allows the user to visualize the values of expressions (evaluating to integers or clocks) along simulated runs. This gives insight to the user on the behavior of the system so that more interesting properties can be asked to the model checker. The concrete syntax applied in Uppaal SMC is as follows: simulate N [< =bound]{E1, .., Ek} where N is a natural number indicating the number of simulations to be performed, boundis the time bound on the simulations, and E1, .., Ek are the k (state-based) expressions that are to be monitored and visualized. To demonstrate this on our previous train-gate example, we can monitor when Train(0) and Train(5) are crossing as well as the length of the queue. The query is 123 Uppaal SMC tutorial value Simulations 6.0 4.5 Train[0].Cross Train[5].Cross 1.5 3.0 Gate.len 0 0 50 100 150 200 250 300 time Fig. 6 Visualizing the gate length and when Train(0) and Train(5) cross on one random run simulate1[<=300] {Train(0).Cross, Train(5).Cross, Gate.len} This gives us the plot of Fig. 6. Interestingly, Train(5) crosses more often (since it has a higher arrival rate). Secondly, it seems unlikely that the gate length drops below 3 after some time (say 20), which is not an obvious property from the model. We can conﬁrm this by asking Pr[<=300](<> Gate.len < 3 and t > 20) and adding a clock t. The probability is in [0.102, 0.123]. For specifying properties over NSTAs, we use a weighted extension of the temporal logic MITL [2] expressing properties over runs [6], deﬁned by the grammar: ϕ::=ap |¬ϕ|ϕ1 ∧ϕ2 |Oϕ|ϕ1Ux ≤d ϕ2 where ap is a conjunction of predicates over the state of a NSTA, d is a natural number and x is a clock. Here, the logical operators are interpreted as usual, and O is a next state operator. A weighted MITL formula ϕ1U≤ xd ϕ2 is satisﬁed by arun if ϕ1 is satisﬁed on the run until ϕ2 is satisﬁed, and this will happen before the value of the clock x exceeds d. As usual ¬(ϕ1 ∧ϕ2) =¬ϕ1 ∨¬ϕ2 and we use standard MITL abbreviations tt = ϕ ∨¬ϕ, ♦x≤d ϕ = ttU≤ xd ϕ and x≤d ϕ =¬♦x≤d ¬ϕ. For an NSTA M, we deﬁne PM (ϕ) to be the probability that a random run of M satisﬁes ϕ. The problem of checking PM (ϕ) ≥ p (p ∈[0, 1]) is undecidable in general.1 For the sub-logic of cost-bounded reachability problems PM (♦x≤C ap) ≥p, where x is a clock and C is a bound, Uppaal SMC approximates the answer using simulation-based algorithms known under the name of statistical model checking [41] algorithms (SMC). We brieﬂy recap statistical algorithms permitting to answer the following three types of questions: 1. Probability estimation What is the probability PM (♦x≤C ap) for a given NSTA M? 1 Exceptions being stochastic TAs with 0 or 1 clocks and with p being 0or1. 1 P 0 Fig. 7 True probability P and conﬁdence intervals 2. Hypothesis testing Is the probability PM (♦x≤C ap) for a given NSTA M greater or equal to a certain threshold p ∈[0, 1]? 3. Probability comparison Is the probability PM (♦x≤C ap1) greater than the probability PM (♦y≤Dap2)? From a conceptual point of view solving the above questions using SMC is simple. First, each run of the system is encoded as a Bernoulli random variable that is true if the run satisﬁes the property and false otherwise. Then a statistical algorithm groups the observations to answer the three questions. For the quantitative question (1), we will use an estimation algorithm that resemble the classical Monte Carlo simulation, while for the qualitative questions (2 and 3) we shall use sequential hypothesis testing. The two solutions are detailed hereafter. Probability estimation The probability estimation algorithm [30] computes the number of runs needed to produce an approximation interval [p −ε, p +ε]for p = Pr(ψ) with a conﬁdence 1 −α. A frequentist interpretation of this result tells us that if we repeat the interval estimation N times, then the estimated conﬁdence interval p ±ε contains the true probability at least (1−α)N times in the long run (N →∞). Figure 7 shows the relation between the estimated probability conﬁdence intervals and the true (unknown) probability P. The original algorithm for interval estimation decides the number of runs apriori based on the values of ε and α using Chernoff–Hoeffding inequality [18,31], however for practical purposes this inequality is too conservative. Moreover, the result can be even more improved when the probability is further from 12. Uppaal SMC implements a sequential method where a probability conﬁdence interval (for given α) is derived with each new simulation measurement and the simulation generation is stopped when the conﬁdence interval width is less than 2ε. The conﬁdence interval is derived using Clopper–Pearson “exact” method [19] using the fact that the measurements are always binary (the property is either satisﬁed or not) and thus the result follows binomial distribution. The conﬁdence level is also adjusted for one-123 A. David et al. Fig. 8 The Veriﬁer of Uppaal SMC sided intervals, where the measured property is always true or always false. In Uppaal SMC, the probability conﬁdence interval can be estimated by the following query: Pr[bound] (ap) Example 1 Recall the Train Crossing example of the previous section. The following queries estimates the probabilities that Train(0) and Train(5) will be in the crossing before 100 time units: Pr[<= 100](<> Train(0).Cross) Pr[<= 100](<> Train(5).Cross) (1) Figure 8 shows how these (and other) queries are entered in the “Query” ﬁeld of the Veriﬁer tab of Uppaal SMC. In the “Overview” ﬁeld the answers are provided: [0.502421, 0.602316] and [0.902606, 1] are the two 95 % conﬁdence intervals obtained from 383 and 36 runs, respectively. This shows—as we would expect—that the more eager Train(5) has a higher probability of reaching the crossing than Train(0) within the given time limit. Right clicking on the answers provide easy access to more detailed information in terms of (cumulative, conﬁdence interval, frequency histogram) probability distribution of the time-bounded reachability property, e.g., Fig. 9. Hypothesis testing This approach reduces the qualitative question to e test the null-hypothesis: H: p = PM (ψ) ≥ θ against the alternative hypothesis: K :p = PM (ψ) < θ To bound the probability of making errors, we use strength parameters α and β and we test the hypothesis H0: p ≥ p0 Fig. 9 The cumulative probability distribution of Pr[<=T ](<> Train(5).Cross) and H1: p ≤ p1 with p0 = θ + δ0 and p1 = θ − δ1.The interval p0 − p1 deﬁnes an indifference region, and p0 and p1 are used as thresholds in the algorithm. The parameter α is the probability of accepting H0 when H1 holds (false positives) and the parameter β is the probability of accepting H1 when H0 holds (false negatives). The above test can be solved by using Wald’s sequential hypothesis testing [40]. This test computes a proportion r among those runs that satisfy the property. With probability 1, the value of the proportion will eventually cross log(β/(1 − α) or log((1 − β)/α) and one of the two hypothesis will be selected. In Uppaal SMC, we use the following query: Pr[bound] (ψ) >= p0 where bound deﬁnes how to bound the runs. The three ways to bound them are (1) implicitly by time by specifying <=M (where M is a positive integer), (2) explicitly by cost with x<=M where x is a speciﬁc clock, or (3) by number of discrete steps with # <=M. In the case of hypothesis testing p0 is the probability to test for. The formula ψ is either <>q or []q where q is a state predicate. Remark 1 Bounding runs for a number of discrete steps guarantees termination of the simulation. Bounding over time may however result in non-termination if the model is not time diverging. Similarly, bounding over a non-diverging clock can result in non-termination. Uppaal SMC cannot detect if a clock (or time) is diverging in a model thus the modeler needs to ensure this. Example 2 Returning to the Train Crossing example, we may not be directly interested in the actual probability of Train(0) crossing within 100 time units, but merely whether this unknown probability is above 0.2, as reﬂected by the following query (see also Fig. 8): Pr[<= 100](<> Train(0).Cross)>= 0.2 Within a number of runs signiﬁcantly smaller than that of estimating the same probability (383 runs), this property may be 123 Uppaal SMC tutorial conﬁrmed. The number of runs needed by Wald’s sequential hypothesis testing method varies, e.g., posing the above query 5 times, the property was conﬁrming within 66, 62, 65, 67, and 49 runs, respectively, with 5 % level of signiﬁcance. Probability comparison This algorithm, which is detailed in [23], exploits an extended Wald testing. In Uppaal SMC, we use the following query: Pr[bound1](ϕ1)>= Pr[bound2](ϕ2). Example 3 In the train-gate example, it might be sufﬁcient to conﬁrm that the probability that Train(5) reaches the crossing within 100 time units is larger than that of Train(0). Posing the query: Pr[<= 100](<> Train(5).Cross) >= Pr[<= 100](<> Train(0).Cross) conﬁrms this belief within 120 (132, 144, 108, 174) runs with 5 % level of signiﬁcance. In addition to those three classical tests, Uppaal SMC also supports the evaluation of expected values of min or max of an expression that evaluates to a clock or an integer value. The syntax is as follows: E[bound; N ](min:expr) or E[bound; N](max:expr) where bound is as explained in this section, N gives the number of runs explicitly, and expr is the expression to evaluate. Also for these properties a conﬁdence interval is given using the fact that measurements follow Student’s t-distribution (approaching Normal distribution when N →∞). Example 4 As an interesting property of the Train Crossing example, we want to know the average of the maximum number of trains that are stopped within the ﬁrst 20 time units: E[ <=20; 20000] (max: sum(i : id_t) Train(i) .Stop) Using the explicitly required 20.000 runs, this average is estimated to be in the conﬁdence interval 3.64775 ± 0.0126354. Right clicking gives easy access to more detailed views, e.g., the frequency histogram in Fig. 10. Full weighted MITL Regarding the implementation, we note that both the above statistical algorithms are trivially implementable. To support the full logic of weighted MITL is slightly more complex as our simulation engine needs to rely on monitors for such logic. In [7], we proposed an extension of Uppaal SMC that can handle arbitrary formulas of weighted MITL. Given a property ϕ, our implementation ﬁrst constructs deterministic under-and over-approximation monitoring PTAs for ϕ. Then, it puts these monitors in parallel with a given model M, and applies SMC-based algorithms to bound the probability that ϕ is satisﬁed on M.More recently [6], the exact evaluation of whether the generated run satisﬁes a given weighted MITL formula is done online by constantly rewriting the formula during generation of the run. The probability of satisfying an MITL property ψ is estimated by Uppaal SMC using the query Prψ, where ψ:: = BExpr |(ψ && ψ)| (ψ || ψ) |(ψ U[a, b] ψ)| (ψ R[a, b] ψ) |(<>[a, b] ψ)| ([][a, b] ψ) a, b ∈ N, a ≤ b and BExpr is a Boolean expression over clocks, variables and locations. Example 5 The following query: Pr( <>[10,100] ([ ][0,5] Train(0) .Stop) ) asks for the probability that Train(0) will stopped for at least 5 consecutive time units somewhere in the time interval [10, 100]. Within 738 runs [0.880894, 0.980894] is returned as a 95 % conﬁdence interval indicating that this happens with a very high probability. 4 Extension to hybrid systems Uppaal SMC allows for statistical model checking of stochastic hybrid systems, i.e., extensions of (stochastic) timed automata, where the rate of clocks may be given by general expressions involving clocks, thus effectively using ODEs. To illustrate the various aspects of the (extended) modeling formalism supported by Uppaal SMC, we consider the case of two independent rooms that can be heated by a single heater shared by the two rooms, i.e., at most one room can be heated at a time. Figure 11a shows the automaton for the heater. It turns itself on with a uniform distribution over time 123 A. David et al. (a) (b) (c) Fig. 12 Evolution of the temperatures of the two rooms (color ﬁgure online) in-between [0, 4]time units. With probability 1/4 room 0 is chosen and with probability 3/4 room 1. The heater stays on for some time given by an exponential distribution (rate 2 for room 0, rate 1 for the room 1). In summary, one may say that the controller is more eager to initiate the heating of room 1 than room 0, as well as less eager to stop heating room 1. The rooms are similar and are modeled by the same template instantiated twice as shown in Fig. 11b, c. The room is initialized to its initial temperature and then depending on whether the heater is turned on or not, the evolution of the temperature is given by Ti =−Ti /10 + 0,1 Ai, j (Tj −Ti ) orj= Ti = K −Ti /10 + 0,1 Ai, j (Tj −Ti ) where i, j =0, 1j= are room identiﬁers. The sum expression corresponds to an energy ﬂow between rooms and matrix A encodes the energy transfer coefﬁcient between adjacent rooms. Furthermore, when the heater is turned on, its heating is not exact and is picked with a uniform distribution of K ∈[9, 12], realized by the update K=9+random(3). This example illustrates the support for stochastic hybrid systems in Uppaal SMC with extended arithmetic on clocks and generalized clock rates. Uppaal SMC takes as input networks of stochastic hybrid automata as described above. In addition, the automata support branching edges where weights can be added to give a distribution on discrete transitions. It is important to note that rates and weights may be general expressions that depend on the states and not just simple constants. Remark 2 The ODE solver implemented within Uppaal SMC is ﬁxed time step Euler’s integration method thus the results may be sensitive to the discretization step size. Euler’s method is known to be unstable for stiffs systems thus care must taken when deciding on the discretization step size controlled in the settings of statistical parameters. 4.1 Floating-point support The syntax has been extended to support a double precision ﬂoating-point type (double). This type can be used mixed with clocks for computing or storing arithmetic expressions. Its rate cannot be changed. When using ﬂoating-point types or operations in a model, the model is marked as being hybrid. For such models, model checking is disabled, unless the clocks are declared to be hybrid clock and these clocks nor the ﬂoating-point variables affect the control of the automata, i.e., such variables are inactive and used as costs. 4.2 Example All the new queries of Uppaal SMC described in Sect. 3 are available for stochastic hybrid systems. We illustrate this by a number of queries related to the two-room example from the previous section. We can simulate and plot the temperatures of the two rooms with the query simulate 1 [<=600]{T[0], T[1]} The query request the checker to provide one simulate run over 600 time units and plot the temperatures of Room(0) and Room(1). The heater in this example is purely stochastic and is not intended to enforce any particular property. Yet, the simulation obtained from this query in Fig. 12 shows that the heater is able to maintain the temperatures within (mostly) distinct intervals. We can evaluate on a shorter time scale the probability for the temperature of Room(0) to stay below 30 and the temperature of Room(1) to stay above 5 with the queries Pr[<=100] ([ ] Room(0).Init || T[0] <= 20) Pr[<=100] ([ ] Room(1).Init || T[1] >=7) The results are, respectively, in [0.45, 0.55] and [0.65, 0.75]. The precision and conﬁdence of conﬁdence intervals are user-deﬁned (see later) and inﬂuence the number of runs 123 Uppaal SMC tutorial needed to compute the probability. In this example, for having the precision to be ±0.05 and a conﬁdence of 95 %, we needed 738 runs. In fact, if we are only interested in knowing if the second probability is above a threshold it may be more efﬁcient to test the hypothesis Pr[<=100] ([ ] Room(1).Init || T[1] >=7) >= 0.69 which is accepted in our case with 902 runs for a level of signiﬁcance of 95 %. To obtain an answer at comparable level of precision with probability evaluation, we would need to use a precision of ±0.005, which would require 73778 runs instead. We can test the hypothesis that the heater is better at keeping the temperature of Room(1) above 8 than keeping the temperature of Room(0) below 20 by the following comparison query: Pr[<=100] ([ ] Room(1).Init || T[1] >=7) >= Pr[<=100] ([ ] Room(0).Init || T[0] <= 20) which is accepted in this case with 95 % level of signiﬁcance with just 258 runs. Remark 3 As it can be observed, the MITL speciﬁcations allowed in Uppaal SMC are bounded properties. That is speciﬁcations only depend on a run up to a given time-bound, step-bound or bound on some other quantity deﬁned in the model. Thus, speciﬁcations only express properties of transient behavior of systems, and may or may not be indicative of safety of a deployed system in steady operational state, depending on how long the system takes to settle. However, given knowledge of the size of the model, estimation of probability of unbounded properties may be obtained from the observation of ﬁnite runs as shown in [39]. 5 Extension to dynamic creation of processes An underlying assumption of networks of timed automata is that computer systems are statically encoded. This is however not reality. Instead, systems are composed of a number of threads/processes that interact and capable of spawning other processes/threads. Modeling such dynamic systems in standard Uppaal requires the modeler to model an underlying resource manager. In addition, the model would consist of a large number of components in an inactive state available for the resource manager to “start” whenever a spawn request was made in the model. A necessary assumption for modeling this resource manager is thus that the maximum number of spawned threads during any execution is known in advance (or can be safely over-approximated). This does not only make modeling tedious but also affects analysis time. Uppaal SMC supports instantiating dynamic processes out (a) (b) (c) Fig. 14 Plot of the number of waiting clients and total number of clients. The plot was obtained with the query simulate 1[<= 100]{numOf(Client), sum (c : Client)(c.Wait)} (color ﬁgure online) of the box. Any automata in the system can spawn instances of templates of the model that has been declared to be spawn-able. Dynamically created instances act within the system as the static instances with the exception that they at any time may terminate, and thus remove themselves from the system. In Fig. 13 is a high-level model of a client–server architecture. The model consists of a number of servers (10), shown in Fig. 13a, that listens on all possible input channels req. When a request arrives all the servers will “race” to acknowledge the connection over the channel ack[c]. The winner will proceed to communicate with the client (we abstract from this part), while the others return to their listening state. When a client has ﬁnished communication with the server it will terminate the connection by synchronizing on term[c]. Afterwards, the server returns to its listening state. In Fig. 13b, we show the client side of the model. A client is given an id when spawned which tells it what channel to connect on (req[id]). A client is ﬁrst attempting to get a connection, then it awaits an acknowledgment from a server and then do some work taking less than ten time units. Finally, 123 A. David et al. it disconnects from the server by synchronizing on term[id] and at the same time tears itself down using the exit() construction. Clients are spawned by the template in Fig. 13cusing the spawn Client(next++) update. This instantiates a client and passes the value of next as a parameter to the client which binds that value to its own local variable id. Remark 4 We realize that the template in Fig. 13c may create an unbounded number of clients, whereas the number of communication channels are bounded. For our particular use this is not a problem as we know the number of spawned clients will not exceed the number of communication channels within the time limit we work with in our queries. 5.1 Syntax in Uppaal SMC A template that will be dynamically spawned must be declared as a dynamic template. This is done in the global declaration of the Uppaal model using the dynamic keyword. The declaration for the Client template would for instance be dynamic Client (int id). The template takes one parameter id. Parameters to spawnable templates are restricted to be pass-by-value parameters or a reference to a broadcast channel. The reasoning behind this restriction is that templates may cease to exist—invalidating any references to its local variables that it could have passed on to spawned templates. The actual behavior of a spawnable template is deﬁned as usual in the editor. Note, however, that there must be a correspondence between the parameters deﬁned in the dynamic declaration and the deﬁnition. In the Client example this means that the parameters both in the dynamic declaration and the deﬁnition must be int id. Spawnable templates may be spawned by any template during a transition using the spawn keyword. For instance, adding spawn Client (2) to the update expression of an edge will spawn an instance of the template Client with parameter 2. Obviously, there must be parameter compatibility between the actual and the formal parameters. A spawnable template can tear itself down during a transition. This is expressed by adding the exit() expression to the update of an edge. 5.2 Extensions for queries Having extended the modeling language of Uppaal SMC to allow dynamically spawning templates, we also need an extended speciﬁcation formalism. For the statically deﬁned components speciﬁcations are made as described in Sect. 3. For the dynamically created components of the system three additional constructions are available: forall (i : T)(q), exists (i : T)(q)and sum (i : T)(a), that may be used anywhere in a speciﬁcation. The predicate forall(i:T) (q) asserts that q is true for all the dynamically created instances of T. The name i may be used anywhere in q to refer to the variables of the instances of T, i.e., the name i is temporally bound to the instances of T while evaluating q. The construct exists (i:T) (q) is the dual of forall. Example 6 Returning to the server example from before, we may consider the probability that a client is not served for 5 time units, i.e., that it is working in the Wait location for 5 time units. In the extended speciﬁcation formalism this can be checked using the query: Pr(<>[0,20] (exists (c : Client) (([ ][0,5]c.Wait)))) The expression sum (i : T)(a) can be used in arithmetic expressions and simply evaluates a for all the instances of T. In the Server example, we can for instance count the number of clients that are waiting for a connection with the expression sum (c : Client)(c.Wait). The sum construction can also be used to count the number of active clients sum (c : Client)(1). An optimized version of this is available as numOf(Client).InFig. 14, we show one simulation, 100 time units long, where we observe these two expressions. The sum operator is useful for computing aggregate data about all components of a given type but cannot give the exact value of each component. For instance, sum cannot be used to plot the location of each client. If this is wanted Uppaal SMC supports the query: simulate1[<=100] {foreach (c : Client) (3*C.id+c.Wait+2*c.Work)} The foreach statement is here used to tell the plotting facility of Uppaal SMC to plot the expression 123 Uppaal SMC tutorial (3*c.id+c.Wait+2*c.Work) for each of the dynamically instances of Client. The actual expression is just a smart way to obtain a “Gantt-like” chart of each client. The result of the query is shown in Fig. 15 where each colored line correspond to a client. 6 Graphical interface We focus in this section on the main features of the interface related to SMC. For a more complete overview of the interface the reader is referred to [4]. Overview The graphical interface of Uppaal is divided into an editor, two simulators, and a veriﬁer. The editor serves the purpose to deﬁne the automata and declaration of variables and functions. The veriﬁer is used to specify and check different queries, and to get the results. Then there are two simulators, one is the well-known symbolic simulator that has been available in Uppaal since the birth of this interface. The second simulator is a concrete simulator that was originally used in Uppaal-tiga. This simulator allows the user to simulate a system with concrete values of clocks, which is more intuitive than with the symbolic simulator. This simulator is shown in Fig. 16. The choice of transition is situated in the upper-left corner. The user chooses with one click a transition (vertical choice) and a delay (horizontal choice). The simulator shows the automata and a message sequence chart on the right. On the lower left corner is the trace corresponding to the current simulation. The central view shows the variables and the user can show and hide variables in different scopes. In the example, only the clocks of Train(2) and Train(4) are shown. The concrete simulator also supports Gantt chart visualization of the interactive concrete trace. Figure 17 shows a sample use case of Gantt chart for the train-gate example. The chart is deﬁned in system declarations (Fig. 17a), where each chart line is deﬁned by a statement separated by a semicolon. Each statement consists of a line label (e.g., gate and train) and a comma-separated list of predicates implying color numbers. For example, a line gate is painted in color #0 (red) whenever Gate.Occ is true and in color #1 (green) whenever Gate.Free. The colors are mixed when the corresponding predicates are true at the same time. It is also possible to deﬁne a chart line for a whole range of discrete values at once, like the parameterized deﬁnition of train(i:id_t), where the temporary variable i has a range of type id_t.For example, the ﬁrst 32 colors can be rendered by the following deﬁnition: gantt { C(i:int[0,31]): true -> i; }. 123 A. David et al. (a) (b) SMC options Under the menu Options the user can choose Statistical parameters. This opens the window shown in Fig. 18. – −δ and +δ: When testing for hypothesis of the form Pr(ϕ) ≥ θ , the algorithm behind tests for two hypothesis. They are 1) H0 : Pr(ϕ) ≥ θ + δ+ and 2) H1 : Pr(ϕ) ≤ θ − δ−. These parameters deﬁne the region of indifference. – α and β: α and β are used for hypothesis testing. The probability of accepting H1 instead of H0 is α and conversely for β. In the case of probability evaluation, α is also used and it is then the probability to be outside the result interval of probability. For probability comparison, the use of α and β is the same as for hypothesis testing. – ε is the uncertainty for probability evaluations. The tool evaluate some probability μ and outputs the result [μ − ε, μ + ε]. – u0 and u1 are the lower and upper bounds used in probability comparison. Similarly to hypothesis testing, the Pr(ϕ1)algorithm tests two hypotheses: H0 :≥ u1 andPr(ϕ2) Pr(ϕ1)H1 :≤ u0. These parameters deﬁne the region of Pr(ϕ2) indifference for comparing probabilities. – Histogram parameters: If the bucket width is set to a positive value, its value determines the width of the bars in the histogram and the number of bars depends on the range of the obtained results. Otherwise if the bucket count is positive then the number of bars is set to this value and the width of the bars depends on the range of the obtained result. Otherwise if both parameters are set to zero (default), the number of bars in the histogram is set to the square root of the number of runs used to obtain the graph. – Trace resolution: When computing a simulation using the simulate query, the tool ﬁlters out the data on-the-ﬂy and retains points that are distinguishable w.r.t. a certain resolution when plotted on a screen. This parameter controls the maximum width of the plot in pixels. – Discretization step: This is used for integration when ODEs are used in the model. We note that deﬁning rates as constants does not qualify as ODE, but having x’==y does. Plotting and composing Most of SMC queries also provide quick result visualization in a form of data plots accessible in the Veriﬁer by right clicking on a selected property and choosing one of the available plots from a pop-up menu. Simulation queries display all the requested trajectories in one plot with different colors assigned to various expressions. Statistical queries result in a number of different histograms showing the data scattered along time, cost or discrete transitions horizontal axis. The displayed plot elements (like title, legend, transparency, comments and logarithmic scale) can be customized by right clicking on the plot and choosing appropriate items from a pop-up menu. The plotted data can be exported as either a picture or a text ﬁle using the same plot pop-up menu. The size of the exported plot can be customized by resizing the plot window. Note that larger window will result in smaller fonts when rescaled for inclusion into a document, so smaller window will result in fewer details but clearer picture with larger fonts. The dark-colored areas are printer-friendlier when the plot is brightened by choosing Areas/Bright in the plot pop-up menu. 123 Uppaal SMC tutorial Different data can also be contrasted and compared in one plot using the Plot Composer from the Tools menu. Figure 19 shows a sample Plot Composer window with data from several veriﬁcations already loaded. The bottom panel on the right shows the resulting plot and the data is organized in the tree on the left. Each veriﬁcation data is appended to the tree to its corresponding query. For example, simulate query has been checked four times and each result contains one plot with two datasets. The data can be added to the composite plot by ticking its checkbox and its drawing properties can be customized in the top-right panel when it is selected in the tree. For example E2 and E4 are ticked in Fig. 19 and E2 is selected and drawing properties can be changed. The main plot attributes like the title and the labels of both axis can be changed by selecting the root node and changing its properties in the upper panel on the right. It is also possible to edit several composite plots at the same time by invoking Plot Composer several times from the Tools menu. 7 Modeling tricks 7.1 How to convert channel synchronizations into broadcast synchronizations Problem It is common that a user wants to analyze performance of a given model previously model checked with Uppaal. This model may contain ordinary channel synchronizations that work by hand shake. The problem is that the SMC extension does not support them as explained in Sect. 2. Here, we present a translation to convert these models so that they can be analyzed by Uppaal SMC. Translation We distinguish three cases: the basic simple oneto-one synchronization, the one-to-any synchronization, and a problematic case. The common simple case is of one process synchronizing with exactly one other process on a channel as shown in Fig. 20. The sender in state A may have an invariant or not. The receiver in state Loc2 does not have an invariant. The synchronization may be guarded by, resp. g1() and g2(),for resp. the sender and the receiver. To convert this model, the user should redeclare the channel a as broadcast, move the guard of the receiver to the sender,2 and make the actual location visible from the sender using a simple encoding with the extra integer variable recvLoc. Other encodings may be used, e.g., with booleans, but the integer presents the advantage to keep the translation of several synchronizations simple. The integer allows the user to map each location to a unique value that is used by the sender to allow the synchronization only in the right state. The example illustrates the update of this 2 This may require moving local variables to the global scope to make the state visible. ⇓ variable for some other peripheral locations Loc0, Loc1, and Loc4. The second more general case is of one process synchronizing with one process out of several ones. There is a choice of one-to-any synchronization shown in Fig. 21. Here as well, the receiver is in a location without invariants. In this case, the same principle as the simple case is used with in addition a renaming of the channel. The initial transition in the sender has a copy with a unique channel name for each possible synchronization that is possible in the original model. Each copy uses the right associated guard and looks up the state of the right process. In the example, we illustrate with the use of an array a generic encoding where there would be several instances of the same template for the receiver. If the guards g2() and g3() are generic or depend on some id used to instantiate the receivers, the select construct can be used, in which case the original transition is not copied and the channel a is renamed as a[id] with an array. The last case is the problematic one where a receiver has an invariant as shown in Fig. 22. Any translation of this model will violate the independent progress condition because here a receiver would force another sender process to synchronize. Not synchronizing would result in a deadlock. We note that if there is an output from that location, i.e., some b! synchronization, then there is no problem. The last technical detail to take care of is to add exponential rates to the locations without invariants and that have output synchronizations (or tau transitions). This is the rate of the exponential distribution used for picking delays. 123 A. David et al. ⇓ Fig. 22 Problematic case where the translation to broadcast channel is not possible 7.2 How to encode custom distributions tributions available in Uppaal SMC are not enough. The user needs a simple way to encode any distribution into the model to generalize the ones illustrated in Fig. 2. Encoding The pattern for encoding general distributions is given in Fig. 23. The principle is that upon entry of a given location Wait where the actual custom delay is to take place, the actual delay is computed and stored into a clock delay. The function f() that computes this delay returns a ﬂoating-point value of type double. The automaton will then delay for this amount and take the transition. The location Wait has its invariant set to x <= delay and delay’==0. The clock delay is used here only for storage. This technique is similar to the one used for computing stochastic simulations in Modest [27]. Implementation of f() The function that computes the delay may use the random(n) function with n being a ﬂoating-point value. The function returns a number in [0, n[ with a uni-Fig. 23 Result from modeling a Gaussian distribution Fig. 24 Pattern for custom delay distributions form distribution. This can then be transformed to return a delay with another distribution. We note that the function may keep a state as well, by storing what it wants into global variables (also of type double), which allows the encoding of virtually any distribution. For example, to generate random numbers according to a normal distribution using the Box-Müller method, we can use the following function: The distribution obtained is shown in Fig. 24 together with the parameters used. Remark The reader may wonder why the pattern proposes to use a clock for the variable delay instead of a variable of type double. In fact, it is possible to use double, which saves the trouble of setting its rate to 0. However, the performance of the model checker may drop. In its current implementation, Uppaal SMC uses a ﬁned-grained discretization if guards or invariants contain a “general” ﬂoating-point expression. The syntax analyzer will not recognize that the discretization is not needed in this case. Using clocks alleviates the problem. 7.3 How to model physics Problem The formalism of Uppaal SMC is stochastic hybrid automata so modeling physics is a simple matter of writing 123 Uppaal SMC tutorial the ODEs in the model. However, only ﬁrst-degree derivatives are allowed. Modeling To model an n-degree derivative, the user should use a clock variable for every intermediate derivative. This is standard renaming technique used in other tools, e.g., Matlab. For example, instead of modeling y’’==-9.81 for a falling object, the user should declare y’==v and v’==-9.81. Using different clocks or arithmetic expressions mixing double typed variables is also supported. 7.4 How to model biochemistry Problem Cyber-physical systems may involve chemical and even biological processes and hence there is a need to evaluate the performance of control systems in such a context. Suppose the reaction involves a mixed solution of materials A and B and produce C and D with reaction speed of γ : γA + 2B −→ C + 3D Here, we show how this reaction can be modeled as either probabilistic or dynamical system. The containment of reactions and other interactions can be modeled by adding additional locations, edges and channel synchronizations. Stochastic model Figure 25 shows a stochastic model of the reaction and its behavior. The discrete quantities (molecules) of the materials involved are counted by the corresponding integers A, B, C and D. The reaction rate is represented by the double precision ﬂoating-point variable gamma.The automaton in Fig. 25b captures the interaction between chemicals A and B in the following way: – The automaton takes a discrete transition when the reaction happens. – The reaction requires at least one molecule of A and at least two molecules of B, hence the edge is guarded by an expression A > 0&&B > 1. – Each reaction consumes A and 2B and produces C and 3D, hence the edge has the update A--, B-=2, C++, D+=3. – In a well-mixed (homogeneous) compound the probability of a reaction is proportional to its speed γ and the probability of meeting the required three molecules (A, B and another B) in one place. The probability of reaction remains the same as long as the conditions (quantities and temperature) do not change, hence the reaction is a Poisson process and the delay until the next reaction follows an exponential distribution with the rate gamma∗ A∗ B∗ B. If there are more reactions, then they have to be modeled by another parallel process. The trajectory of the quantities can be inspected by the following query: simulate 1[ <= 5]{ A, B, C, D} . The resulting plot is shown (a) (b) (c) Fig. 25 Stochastic model and its behavior, a declarations, b automaton, c simulation (color ﬁgure online) (a) (c) in Fig. 25c: A and B are slowly decaying, replaced by C and D. We notice that the trajectory is jittery and can be slightly different with every new simulation due to probabilistic nature of the stochastic process and relatively small amounts of molecules. The trajectories are smoother when quantities are much larger and approach the limit of the continuous dynamics. Scaling Usually, chemical reactions involve huge numbers of molecules with different orders of magnitude and thus some scaling of dimensions may be desired. Note that if the quantities are scaled by 1,000, then the exponential rate gamma∗ A∗ B∗ B has to be scaled by 106 (while the dynamical coefﬁcients are scaled by 109) and thus it is very easy to overﬂow the default range of int. Figure 26 shows the same model but with molecule quantities scaled by 1,000. The simulated trajectories are divided by s back down to a comparable scale as in previous and next example. The simulated behavior is smoother and closer to the dynamical model (shown next). 123 A. David et al. The default integer range is rather small (±216), thus one may need to broaden it by deﬁning a custom range. Uppaal supports integer ranges up to 32 bits, hence the type declaration typedef int[−(1 << 31), (1 << 31) −1]int32_t;corresponds to a range of signed 32 bit integer. The range can be expanded further to a double precision ﬂoating point, but note that its precision is limited to 52 bits (≈4.5×1012) and hence beyond that point minor increments (like +1) will not affect the variable value anymore. Dynamical model The same reaction can be rewritten using a set of differential equations describing the rate of change of the quantities: ⎧ d[A] =−γ ·[A]·[B]2 dt ⎪ d[B]⎨ =−γ ·[A]·[B]2 ·2 dt d[C] = γ ·[A]·[B]2 dt ⎪ d[D]⎩ = γ ·[A]·[B]2 ·3 dt The idea here is that the rate of change in quantities is proportional to the speed of reaction and concentration of materials. The contribution to various materials is then scaled by coefﬁcients from the original reaction. We have one equation per each material mentioned. If there are more reactions then their contributions can be added up to the same system of differential equations either as separate extra terms or a separate equation for each new chemical. Figure 27 shows the dynamical model and its behavior. The quantities are captured by dynamical clock variables A, B, C and D and the same reaction coefﬁcient gamma. The differential equations are then typeset as a single invariant of derivative expressions in Lagrange’s prime notation (Fig. 27b). We also added an escape transition if/when the quantity of A reaches zero, i.e., the reaction stops. The trajectories can be inspected by the same simulation query as previously and the result is shown in Fig. 27c. Notice that the trajectory is smoother, very close to the scaled-up stochastic simulation, and is the same every time (deterministic), because ordinary differential equations have one ﬁxed solution for the same initial conditions. Some ODE systems might require tuning the discrete integration step in the Statistical parameters from the Options menu: the smaller the step the more precise simulation is, but it is also computationally more expensive. Stiff systems may require smaller integration steps. A more complicated biochemical model can be found in a study of a circadian rhythm genetic oscillator [20,24]. 7.5 How to obtain distributions over costs When the user checks queries to evaluate probabilities, e.g., Pr[<=100](<> Proc.Goal), Uppaal SMC keeps track of (a) (c) (a) (b) (c) Fig. 28 Cost estimation in terms of energy, a model, b trajectories of energy and power, c estimated energy probability distribution (color ﬁgure online) when the runs satisfy the speciﬁed goal state and uses this information to build a frequency histogram. Speciﬁcally, what is counted is the number of runs that were satisﬁed at a given “time” as deﬁned by the bound of the run. When no explicit variable is used, e.g., <=100, the plot is the count of satisﬁed runs as a function of time, discretized in the histogram bars (so in fact in function of time intervals). When a clock variable is used, the plot is in function of this variable. Alternatively, the runs can be bound by number of discrete steps of the form # <=100. Now suppose that we want to estimate a cost expressed as some energy consumption. To illustrate this, let us consider the example in Fig. 28a. In this model, a random power level is chosen stochastically and the corresponding energy consumption is integrated by Uppaal SMC. The evolution of the energy is naturally expressed by the equation E’==P. 123 Uppaal SMC tutorial Figure 28b shows one stochastic simulation bounded by two time units obtained with the query simulate 1[<= 2]{E, P}. Every run will have its own energy consumption. The question is to know the mean of the energy consumption and its distribution over runs bounded by two time units. To obtain this we check the query Pr[E <= 10](<> t == 2). The trick is that ﬁrst we bound the actual energy by a high enough bound that covers the reachable range for all runs. It could be E <= 1000 if the user is unsure. Second, the goal state is the time bound that will be reached since time progresses.3 The result probability is one but this is not the point. The point is the distribution generated by this query. Uppaal SMC will record “when” (in function of the bound) the runs reach the goal, here t==2. We obtain now a distribution of energy consumption on runs bounded by two time units as shown in Fig. 28c. Remarks If the suggested query is checked with the default settings the obtained histogram will have poor precision because Uppaal SMC does not need many runs to conclude that the result probability is one. The user should increase the precision by changing the SMC options as described in Sect. 6. Speciﬁcally, Fig. 28c was obtained from 7598 runs using α = 0.001 and ε = 0.0005. It is also possible to estimate discrete costs even though the tool does not support integers as bounds. Users can use clocks for this purpose by maintaining their rates to zero and updating them manually. For example, if c is a counter, then it is declared as a clock. Then the user adds one process with one location and no transition with the invariant c’==0. Finally, the increment c=c+1 is used wherever necessary and the bound c <= 100 can now be used. 7.6 How to model custom discretizations Problem Sometimes users want to use a custom integration method or want to change the integration granularity at the level of locations. Uppaal SMC uses a global time step when it detects that some integration is needed. It may be better for performance or precision to change this step depending on the locations and the type of equation to integrate. Modeling The modeling trick consists of using a “high” exponential rate on the locations where the manual discretization is needed. The tool will then take small delay steps, albeit random according to an exponential distribution with high rate, which allows for custom discretization. Figure 29 shows an example of the temperature of a room that can have a heater turned on or off.4 The value of RATE controls the precision. The functions for cooling and heating are depicted in Listing 3 Uppaal SMC detects Zeno runs and rejects models producing them. 4 The actual controller is not important for this example and is not given here. (a) (b) (c) Fig. 29 The temperature of a heated room with a manual discretization using a high exponential rate RATE, a variable and function declarations, b the model, c temperature trajectories 29a. The value of the clock dt is the time elapsed and is used for the integration. KHEAT and KCOOL are constants used in the model. The result of a simulation is shown in Fig. 29. This manual encoding replaces, resp., T’==-T/KCOOL and T’==KHEAT-T/KCOOL for, resp., cooling and heating. The example also illustrates a recent new feature of the language, namely initializers for clocks with the declaration T = T0[i], where T0 is declared as const double T0={70.0,60.0}. 8 Conclusion This paper presented Uppaal SMC as an efﬁcient tool for evaluating performance properties of stochastic hybrid systems. The modeling language has been extended to handle dynamical behaviors, discrete probabilities, a stochastic interpretation for timed delays and even dynamic process creation—far beyond analytically tools reach. Most importantly the old Uppaal models require only small changes to beneﬁt also from Uppaal SMC features, thus it is straightforward to gain also performance measures in addition to ﬁrm results. The paper also includes tricks for handling more problematic corner cases to satisfy Uppaal SMC assumptions and in particular how to transform handshake synchronization to broadcast synchronization. The query language has been expanded to request simulation trajectories, compute probabilistic aspects and evaluate weighted MITL formulas. In the future, we intend to include better ODE solvers to improve dynamical simulations and improve the interactive concrete run simulator including a Gantt chart visualization of a run. 123 A. David et al. Acknowledgments The research leading to these results has received funding from the European Union Seventh Framework Programme (FP7/2007–2013) under grant agreements No. 318490 (SENSATION) and No. 601148 (CASSTING). Also the research has received funding from the Sino-Danish Basic Research Center IDEA4CPS funded by the Danish National Research Foundation and the National Science Foundation China. EU ARTEMIS grant agreement No. 269335 (MBAT). References 1. Alur, R., Dill, D.L.: A theory of timed automata. Theor. Comput. Sci. 126(2), 183–235 (1994) 2. Alur, R., Feder, T., Henzinger, T.A.: The beneﬁts of relaxing punctuality. J. ACM 43(1), 116–146 (1996) 3. Boyer, B., Corre, K., Legay, A., Sedwards, S.: Plasma-lab: a ﬂexible, distributable statistical model checking library. In: QEST, pp. 160–164 (2013) 4. Behrmann, G., David, A., Larsen, K.G.: A tutorial on Uppaal. Lecture Notes in Computer Science. pp. 200–236 (2004) 5. Behrmann, G., David, A., Larsen, K.G., Pettersson, P., Yi, W.: Developing uppaal over 15 years. Softw. Pract. Exp. 41(2), 133– 142 (2011) 6. Bulychev, P., David, A., Larsen, K.G., Legay, A., Li, G., Poulsen, D.B.: Rewrite-based statistical model checking of wmtl. In: Runtime Veriﬁcation, vol. 7687 of LNCS, pp. 260–275 (2012) 7. Bulychev, P., David, A., Larsen, K.G., Legay, A., Li, G., Poulsen, D.B., Stainer, A.: Monitor-based statistical model checking for weighted metric temporal logic. In: Nikolaj, B., Voronkov, A. (eds.) 18th International Conference on Logic for Programming, Artiﬁcial Intelligence, and Reasoning, vol. 7180 of LNCS, pp. 168–182. Springer (2012) 8. Bulychev, P.E., David, A., Larsen, K.G., Legay, A., Mikucionis, M., Poulsen, D.B.: Checking and distributing statistical model checking. In: NASA Formal Methods, vol. 7226 of Lecture Notes in Computer Science, pp. 449–463. Springer (2012) 9. Behrmann, G., David, A., Larsen, K.G., Yi, W.: Uniﬁcation & sharing in timed automata veriﬁcation. In: SPIN Workshop 03, vol. 2648 of LNCS, pp. 225–229 (2003) 10. Behrmann, G.: Distributed reachability analysis in timed automata. STTT 7(1), 19–30 (2005) 11. Behrmann, G., Fehnker, A., Hune, T., Larsen, K.G., Pettersson, P., Romijn, J.: Efﬁcient guiding towards cost-optimality in uppaal. In: Margaria, T., Yi, W. (eds.) Proceedings of the 7th International Conference on Tools and Algorithms for the construction and analysis of systems, number 2031 in Lecture Notes in Computer Science, pp. 174–188. Springer (2001) 12. Behrmann, G., Fehnker, A., Hune, T., Larsen, K.G., Petters-son, P., Romijn, J., Vaandrager, F.: Minimum-cost reachability for priced timed automata. In: Di Benedetto, M.D., Sangiovanni-Vincentelli, A. (eds.) Proceedings of the 4th International Workshop on Hybris Systems: Computation and Control, number 2034 in Lecture Notes in Computer Sciences, pp. 147–161 Springer-Verlag (2001) 13. Behrmann, G., Hune, T., Vaandrager, F.: Distributed timed model checking: How the search order matters. In: Proceedings of 12th International Conference on Computer Aided Veriﬁcation, Lecture Notes in Computer Science, Chicago, Springer, Jul (2000) 14. Broy, M., Jonsson, B., Katoen, J-P., Leucker, M., Pretschner, A. (eds.): Model-based testing of reactive systems, advanced lectures the volume is the outcome of a research seminar that was held in Schloss Dagstuhl in January 2004, vol. 3472 of Lecture Notes in Computer Science. Springer (2005) 15. Behrmann, G., Larsen, K.G., Pearson, J., Weise, C., Yi, W.: Efﬁcient timed reachability analysis using clock difference d iagrams. In: Proceedings of the 12th Int. Conf. on Computer Aided Veriﬁcat ion, vol. 1633 of Lecture Notes in Computer Science. Springer (1999) 16. Clarke, E.M., Faeder, J.R., Langmead, C.J., Harris, L.A., Jha, S.K., Legay, A.: Statistical model checking in biolab: applications to the automated analysis of t-cell receptor signaling pathway. In: CMSB, LNCS, pp. 231–250 (2008) 17. Clarke, E., Grumberg, O., Peled, D.: Model Checking. MIT Press, Cambridge (1999) 18. Chernoff, H.: A measure of asymptotic efﬁciency for tests of a hypothesis based on the sum of observations. Ann. Math. Stat. 23(4), 493–507 (1952) 19. Clopper, C.J., Pearson, E.S.: The use of conﬁdence or ﬁducial limits illustrated in the case of the binomial. Biometrika 26(4), 404–413 (1934) 20. David, A., Du, D., Larsen, K.G., Legay, A., Mikucionis, M., Poulsen, D.B., Sedwards, S.: Statistical model checking for stochastic hybrid systems. In: Bartocci, E., Bortolussi, L. (eds.) HSB, vol. 92 of EPTCS, pp. 122–136 (2012) 21. David, A., Du, D., Larsen, K.G., Legay, A., Mikucionis, M.: Optimizing control strategy using statistical model checking. In: NASA formal methods, vol. 7871 of Lecture Notes in Computer Science, pp. 352–367. Springer (2013) 22. David, A., Jensen, P.G., Larsen, K.G., Legay, A., Lime, D., Søresensen, M.G., Taankvist, J.H.: On time with miniam expected cost 23. David, A., Larsen, K.G., Legay, A., Mikucionis, M., Poulsen, D.B., Vliet, J.V., Wang, Z.: Statistical model checking for networks of priced timed automata. In: FORMATS, LNCS, pp. 80–96. Springer (2011) 24. David, A., Larsen, K.G., Legay, A., Mikucionis, M., Poulsen, D.B., Sedwards, S.: Runtime veriﬁcation of biological systems. In: Margaria, T., Steffen, B. (eds.), ISoLA (1), vol. 7609 of Lecture Notes in Computer Science, pp. 388–404. Springer (2012) 25. David, A., Möller, M.O., Yi, W.: Formal veriﬁcation of UML statecharts with real-time extensions. In: Kutsche, R.-D., Weber, H. (eds.) Fundamental Approaches to Software Engineering, 5th International Conference, FASE 2002, vol. 2306 of LNCS, pp. 218–232. Springer (2002) 26. Henriques, D., Martins, J.G., Zuliani, P., Platzer, A., Clarke, E.M.: Statistical model checking for markov decision processes. In: Ninth International Conference on Quantitative Evaluation of Systems, QEST 2012, London, United Kingdom, Sept 17–20, 2012, pp. 84– 93. IEEE Computer Society (2012) 27. Hartmanns, A.: Model-checking and simulation for stochastic timed systems. In: Bernhard, K.A., De Boer, F.S., Marcello M.B. (eds.) FMCO, vol. 6957 of Lecture Notes in Computer Science, pp. 372–391. Springer (2010) 28. Henzinger, T.A., Ho, P.-H.: Algorithmic analysis of nonlinear hybrid systems. In: Wolper, P. (ed.) Computer Aided Veriﬁcation, 7th International Conference, Liège, Belgium, July, 3–5, 1995, Proceedings, vol. 939 of Lecture Notes in Computer Science, pp. 225– 238. Springer (1995) 29. Hendriks, M., Larsen, K.G.: Exact acceleration of real-time model checking. In: Asarin, E., Maler, O., Yovine, S. (eds.) Electronic Notes in Theoretical Computer Science, vol. 65. Elsevier Science Publishers (2002) 30. Hérault, T., Lassaigne, R., Magniette, F., Peyronnet, S.: Approximate probabilistic model checking. In: Steffen, B., Levi, G. (eds.) Veriﬁcation, Model Checking, and Abstract Interpretation, vol. 2937 of Lecture Notes in Computer Science, pp. 73–84. Springer, Berlin, Heidelberg (2004) 31. Hoeffding, W.: Probability inequalities for sums of bounded random variables. J. Am. Stat. Assoc. 58(301), 13–30 (1963) 32. Jha, S.K., Clarke, E.M., Langmead, C.J., Legay, A., Platzer, A., Zuliani, P.: A bayesian approach to model checking biological systems. In: CMSB, vol. 5688 of LNCS, pp. 218–234. Springer (2009) 123 Uppaal SMC tutorial 33. Jégourel, C., Legay, A., Sedwards, S.: Importance splitting for statistical model checking rare properties. In: CAV, vol. 8044 of Lecture Notes in Computer Science, pp. 576–591. Springer (2013) 34. Kwiatkowska, M.Z., Norman, G., Parker, D.: Prism 2.0: A tool for probabilistic model checking. In: Proc. of 1th Int. Conference on the Quantitative Evaluation of Systems (QEST), pp. 322–323. IEEE (2004) 35. Larsen, K.G., Behrmann, G., Brinksma, E., Fehnker, A., Hune, T., Pettersson, P., Romijn, J.: As cheap as possible: efﬁcient cost-optimal reachability for priced timed automata. In: Berry, G., Comon, H., Finkel, A. (eds.) Proceedings of CAV 2001, number 2102 in Lecture Notes in Computer Science, pp. 493–505. Springer (2001) 36. Larsson, F., Larsen, K.G.,Pettersson, P., Yi, W.: Efﬁcient veriﬁcation of real-time systems: Compact data structures and state-space reduction. In: Proc. of the 18th IEEE Real-Time Systems Symposium, pp. 14–24. IEEE Computer Society Press (1997) 37. Larsen, K.G., Pettersson, P., Yi, W.: Uppaal in a Nutshell. Int. J. Softw. Tools Technol. Transf. 1(1–2), 134–152 (1997) 38. Sen, K., Viswanathan, M., Agha, G.: Statistical model checking of black-box probabilistic systems. In: CAV, LNCS 3114, pp. 202– 215. Springer (2004) 39. Theelen, B.D.: Performance modelling for system-level design. Ph.D. thesis, Eindhoven University of Technology, (2004) ISBN 90-386-1633-3 40. Wald, A.: Sequential tests of statistical hypotheses. Ann. Math. Stat. 16(2), 117–186 (1945) 41. Younes, H.L.S.: Veriﬁcation and planning for stochastic processes with asynchronous events. Ph.D. thesis, Carnegie Mellon (2005) 42. Yi, W., Pettersson, P., Daniels, M.: Automatic veriﬁcation of real-time communicating systems by constraint-solving. In: Proceedings of the 7th IFIP WG6.1 International Conference on Formal Description Techniques VII, pp. 243–258, London, UK, UK, Chapman & Hall Ltd (1995) 123 